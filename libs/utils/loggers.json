{"traceEvents":[{"ph":"M","pid":36076,"tid":36076,"name":"process_name","args":{"name":"MainProcess"}},{"ph":"M","pid":36076,"tid":18660,"name":"thread_name","args":{"name":"MainThread"}},{"pid":36076,"tid":18660,"ts":219253176720.7,"dur":42.3,"name":"builtins.print","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176768.6,"dur":0.3,"name":"builtins.hasattr","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176769.1,"dur":0.2,"name":"sys._getframe","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176768.3,"dur":1.2,"name":"currentframe (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\inspect.py:1520)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176771.5,"dur":0.6,"name":"<genexpr> (D:\\githubs\\DR\\libs\\utils\\py_logger.py:360)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176772.3,"dur":0.2,"name":"<genexpr> (D:\\githubs\\DR\\libs\\utils\\py_logger.py:360)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176771.0,"dur":1.9,"name":"str.join","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176774.2,"dur":0.2,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176776.5,"dur":0.5,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176776.2,"dur":1.5,"name":"_compile (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\re.py:289)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176778.0,"dur":2.7,"name":"re.Pattern.sub","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176775.8,"dur":5.0,"name":"sub (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\re.py:203)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176781.0,"dur":0.1,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176774.9,"dur":6.3,"name":"len_without_color_maker (D:\\githubs\\DR\\libs\\utils\\py_logger.py:465)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176782.0,"dur":0.3,"name":"dict.copy","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176782.7,"dur":1.0,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176784.8,"dur":0.1,"name":"nt.fspath","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176785.4,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176785.2,"dur":0.4,"name":"_get_bothseps (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:34)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176786.0,"dur":0.02,"name":"nt.fspath","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176786.1,"dur":0.1,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176786.4,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176786.7,"dur":0.2,"name":"str.replace","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176785.8,"dur":2.2,"name":"splitdrive (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:124)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176788.2,"dur":0.02,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176789.8,"dur":0.1,"name":"str.rstrip","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176784.6,"dur":5.7,"name":"split (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:180)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176791.1,"dur":0.5,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176792.7,"dur":0.2,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176793.4,"dur":0.3,"name":"time.time","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176795.2,"dur":0.2,"name":"dict.items","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176795.8,"dur":0.02,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176796.2,"dur":0.02,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176796.4,"dur":0.02,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176796.5,"dur":0.02,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176796.9,"dur":0.3,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176797.5,"dur":0.5,"name":"str.find","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176798.1,"dur":0.2,"name":"str.find","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176798.6,"dur":0.2,"name":"str.replace","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176798.9,"dur":6.7,"name":"time.strftime","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176806.1,"dur":0.02,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176806.4,"dur":0.3,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176806.9,"dur":0.1,"name":"str.find","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176807.1,"dur":0.1,"name":"str.find","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176807.4,"dur":0.2,"name":"str.replace","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176807.62,"dur":4.38,"name":"time.strftime","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176814.7,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176814.9,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176817.1,"dur":2.0,"name":"str.format","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176773.8,"dur":45.5,"name":"format_text (D:\\githubs\\DR\\libs\\utils\\py_logger.py:371)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176820.0,"dur":45.6,"name":"builtins.print","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176767.4,"dur":99.0,"name":"make_log (D:\\githubs\\DR\\libs\\utils\\py_logger.py:348)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176765.8,"dur":101.3,"name":"trace (D:\\githubs\\DR\\libs\\utils\\py_logger.py:390)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176870.1,"dur":0.3,"name":"builtins.hasattr","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176870.5,"dur":0.2,"name":"sys._getframe","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176869.9,"dur":0.9,"name":"currentframe (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\inspect.py:1520)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176872.4,"dur":0.5,"name":"<genexpr> (D:\\githubs\\DR\\libs\\utils\\py_logger.py:360)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176873.0,"dur":0.1,"name":"<genexpr> (D:\\githubs\\DR\\libs\\utils\\py_logger.py:360)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176872.0,"dur":1.5,"name":"str.join","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176874.5,"dur":0.1,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176876.0,"dur":0.4,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176875.8,"dur":1.1,"name":"_compile (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\re.py:289)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176877.1,"dur":1.9,"name":"re.Pattern.sub","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176875.6,"dur":3.5,"name":"sub (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\re.py:203)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176879.2,"dur":0.1,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176875.0,"dur":4.4,"name":"len_without_color_maker (D:\\githubs\\DR\\libs\\utils\\py_logger.py:465)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176880.0,"dur":0.2,"name":"dict.copy","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176880.6,"dur":0.7,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176882.2,"dur":0.02,"name":"nt.fspath","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176882.7,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176882.5,"dur":0.4,"name":"_get_bothseps (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:34)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176883.3,"dur":0.02,"name":"nt.fspath","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176883.4,"dur":0.02,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176883.6,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176883.8,"dur":0.1,"name":"str.replace","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176883.2,"dur":1.5,"name":"splitdrive (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:124)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176884.9,"dur":0.02,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176886.1,"dur":0.1,"name":"str.rstrip","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176882.0,"dur":4.5,"name":"split (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:180)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176887.1,"dur":0.3,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176888.2,"dur":0.2,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176888.8,"dur":0.2,"name":"time.time","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176890.2,"dur":0.02,"name":"dict.items","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176890.6,"dur":0.02,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176890.9,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176891.1,"dur":0.02,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176891.2,"dur":0.02,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176891.6,"dur":0.3,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176892.1,"dur":0.3,"name":"str.find","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176892.6,"dur":0.1,"name":"str.find","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176892.9,"dur":0.1,"name":"str.replace","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176893.1,"dur":6.5,"name":"time.strftime","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176900.0,"dur":0.02,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176902.8,"dur":0.3,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176903.3,"dur":0.1,"name":"str.find","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176903.5,"dur":0.1,"name":"str.find","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176903.7,"dur":0.1,"name":"str.replace","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176903.9,"dur":3.5,"name":"time.strftime","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176907.6,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176907.8,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176909.2,"dur":1.5,"name":"str.format","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176874.1,"dur":36.8,"name":"format_text (D:\\githubs\\DR\\libs\\utils\\py_logger.py:371)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176911.4,"dur":36.7,"name":"builtins.print","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176869.1,"dur":79.6,"name":"make_log (D:\\githubs\\DR\\libs\\utils\\py_logger.py:348)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176868.1,"dur":81.2,"name":"fine (D:\\githubs\\DR\\libs\\utils\\py_logger.py:397)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176951.6,"dur":0.2,"name":"builtins.hasattr","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176951.9,"dur":0.2,"name":"sys._getframe","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176951.4,"dur":0.72,"name":"currentframe (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\inspect.py:1520)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176953.5,"dur":0.4,"name":"<genexpr> (D:\\githubs\\DR\\libs\\utils\\py_logger.py:360)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176953.92,"dur":0.08,"name":"<genexpr> (D:\\githubs\\DR\\libs\\utils\\py_logger.py:360)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176953.2,"dur":1.1,"name":"str.join","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176955.1,"dur":0.1,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176956.5,"dur":0.3,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176956.3,"dur":1.0,"name":"_compile (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\re.py:289)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176957.5,"dur":1.6,"name":"re.Pattern.sub","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176956.0,"dur":3.2,"name":"sub (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\re.py:203)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176959.4,"dur":0.1,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176955.6,"dur":3.92,"name":"len_without_color_maker (D:\\githubs\\DR\\libs\\utils\\py_logger.py:465)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176960.2,"dur":0.2,"name":"dict.copy","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176960.7,"dur":0.6,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176962.2,"dur":0.02,"name":"nt.fspath","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176962.7,"dur":0.02,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176962.5,"dur":0.3,"name":"_get_bothseps (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:34)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176963.1,"dur":0.1,"name":"nt.fspath","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176963.8,"dur":0.02,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176964.0,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176964.2,"dur":0.2,"name":"str.replace","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176963.0,"dur":2.1,"name":"splitdrive (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:124)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176965.2,"dur":0.1,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176966.4,"dur":0.1,"name":"str.rstrip","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176962.0,"dur":4.8,"name":"split (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:180)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176967.4,"dur":0.2,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176968.4,"dur":0.2,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176969.0,"dur":0.2,"name":"time.time","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176970.2,"dur":0.1,"name":"dict.items","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176970.6,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176970.9,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176971.02,"dur":0.08,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176971.2,"dur":0.02,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176971.5,"dur":0.2,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176973.5,"dur":0.3,"name":"str.find","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176973.9,"dur":0.1,"name":"str.find","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176974.2,"dur":0.1,"name":"str.replace","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176974.4,"dur":6.2,"name":"time.strftime","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176980.9,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176981.2,"dur":0.2,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176981.6,"dur":0.1,"name":"str.find","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176981.72,"dur":0.08,"name":"str.find","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176982.0,"dur":0.1,"name":"str.replace","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176982.2,"dur":3.3,"name":"time.strftime","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176985.7,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176985.9,"dur":0.02,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176987.0,"dur":1.4,"name":"str.format","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176954.8,"dur":33.7,"name":"format_text (D:\\githubs\\DR\\libs\\utils\\py_logger.py:371)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176989.0,"dur":35.1,"name":"builtins.print","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176950.9,"dur":73.6,"name":"make_log (D:\\githubs\\DR\\libs\\utils\\py_logger.py:348)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176950.1,"dur":74.9,"name":"debug (D:\\githubs\\DR\\libs\\utils\\py_logger.py:404)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177026.9,"dur":0.3,"name":"builtins.hasattr","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177027.3,"dur":0.2,"name":"sys._getframe","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177026.8,"dur":0.72,"name":"currentframe (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\inspect.py:1520)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177028.7,"dur":0.4,"name":"<genexpr> (D:\\githubs\\DR\\libs\\utils\\py_logger.py:360)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177029.2,"dur":0.1,"name":"<genexpr> (D:\\githubs\\DR\\libs\\utils\\py_logger.py:360)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177028.5,"dur":1.0,"name":"str.join","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177030.3,"dur":0.1,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177031.6,"dur":0.3,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177031.5,"dur":0.9,"name":"_compile (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\re.py:289)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177032.5,"dur":1.4,"name":"re.Pattern.sub","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177031.2,"dur":2.8,"name":"sub (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\re.py:203)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177034.1,"dur":0.1,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177030.8,"dur":3.42,"name":"len_without_color_maker (D:\\githubs\\DR\\libs\\utils\\py_logger.py:465)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177034.7,"dur":0.2,"name":"dict.copy","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177035.2,"dur":0.5,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177036.4,"dur":0.1,"name":"nt.fspath","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177036.9,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177036.8,"dur":0.22,"name":"_get_bothseps (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:34)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177037.4,"dur":0.02,"name":"nt.fspath","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177037.5,"dur":0.02,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177037.7,"dur":0.02,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177037.9,"dur":0.1,"name":"str.replace","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177037.3,"dur":1.4,"name":"splitdrive (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:124)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177038.8,"dur":0.1,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177040.0,"dur":0.1,"name":"str.rstrip","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177036.3,"dur":4.0,"name":"split (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:180)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177040.8,"dur":0.3,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177041.8,"dur":0.2,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177042.3,"dur":0.2,"name":"time.time","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177045.0,"dur":0.1,"name":"dict.items","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177045.3,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177045.7,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177045.9,"dur":0.02,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177046.0,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177046.3,"dur":0.3,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177046.9,"dur":0.2,"name":"str.find","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177047.2,"dur":0.1,"name":"str.find","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177047.5,"dur":0.1,"name":"str.replace","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177047.62,"dur":6.18,"name":"time.strftime","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177054.1,"dur":0.02,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177054.3,"dur":0.3,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177054.7,"dur":0.1,"name":"str.find","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177054.9,"dur":0.1,"name":"str.find","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177055.1,"dur":0.1,"name":"str.replace","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177055.22,"dur":3.18,"name":"time.strftime","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177058.7,"dur":0.02,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177058.8,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177059.8,"dur":1.2,"name":"str.format","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177030.1,"dur":31.0,"name":"format_text (D:\\githubs\\DR\\libs\\utils\\py_logger.py:371)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177061.5,"dur":33.7,"name":"builtins.print","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177026.3,"dur":69.4,"name":"make_log (D:\\githubs\\DR\\libs\\utils\\py_logger.py:348)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177025.6,"dur":70.6,"name":"info (D:\\githubs\\DR\\libs\\utils\\py_logger.py:412)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177098.2,"dur":0.2,"name":"builtins.hasattr","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177098.5,"dur":0.1,"name":"sys._getframe","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177098.1,"dur":0.6,"name":"currentframe (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\inspect.py:1520)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177099.9,"dur":0.3,"name":"<genexpr> (D:\\githubs\\DR\\libs\\utils\\py_logger.py:360)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177100.3,"dur":0.1,"name":"<genexpr> (D:\\githubs\\DR\\libs\\utils\\py_logger.py:360)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177099.6,"dur":1.0,"name":"str.join","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177101.3,"dur":0.1,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177102.7,"dur":0.4,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177102.5,"dur":1.0,"name":"_compile (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\re.py:289)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177103.7,"dur":1.7,"name":"re.Pattern.sub","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177102.2,"dur":3.22,"name":"sub (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\re.py:203)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177105.6,"dur":0.1,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177101.8,"dur":3.92,"name":"len_without_color_maker (D:\\githubs\\DR\\libs\\utils\\py_logger.py:465)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177106.3,"dur":0.1,"name":"dict.copy","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177106.8,"dur":0.7,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177108.3,"dur":0.2,"name":"nt.fspath","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177108.9,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177108.7,"dur":0.4,"name":"_get_bothseps (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:34)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177109.5,"dur":0.02,"name":"nt.fspath","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177109.6,"dur":0.1,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177109.8,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177110.1,"dur":0.1,"name":"str.replace","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177109.4,"dur":1.6,"name":"splitdrive (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:124)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177111.2,"dur":0.1,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177114.1,"dur":0.1,"name":"str.rstrip","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177108.2,"dur":6.3,"name":"split (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:180)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177115.3,"dur":0.4,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177116.5,"dur":0.2,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177117.2,"dur":0.2,"name":"time.time","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177118.6,"dur":0.1,"name":"dict.items","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177119.0,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177119.3,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177119.5,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177119.7,"dur":0.02,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177120.0,"dur":0.4,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177120.7,"dur":0.3,"name":"str.find","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177121.1,"dur":0.2,"name":"str.find","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177121.5,"dur":0.1,"name":"str.replace","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177121.7,"dur":6.9,"name":"time.strftime","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177129.0,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177129.4,"dur":0.2,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177129.8,"dur":0.1,"name":"str.find","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177130.0,"dur":0.1,"name":"str.find","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177130.2,"dur":0.1,"name":"str.replace","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177130.4,"dur":4.0,"name":"time.strftime","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177134.7,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177134.9,"dur":0.02,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177136.3,"dur":1.4,"name":"str.format","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177101.1,"dur":36.7,"name":"format_text (D:\\githubs\\DR\\libs\\utils\\py_logger.py:371)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177138.3,"dur":34.9,"name":"builtins.print","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177097.6,"dur":76.0,"name":"make_log (D:\\githubs\\DR\\libs\\utils\\py_logger.py:348)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177097.0,"dur":77.3,"name":"warning (D:\\githubs\\DR\\libs\\utils\\py_logger.py:420)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177176.6,"dur":0.2,"name":"builtins.hasattr","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177176.9,"dur":0.3,"name":"sys._getframe","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177176.5,"dur":0.72,"name":"currentframe (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\inspect.py:1520)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177178.7,"dur":0.4,"name":"<genexpr> (D:\\githubs\\DR\\libs\\utils\\py_logger.py:360)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177179.12,"dur":0.18,"name":"<genexpr> (D:\\githubs\\DR\\libs\\utils\\py_logger.py:360)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177178.4,"dur":1.1,"name":"str.join","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177180.4,"dur":0.2,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177181.9,"dur":0.4,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177181.8,"dur":0.9,"name":"_compile (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\re.py:289)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177182.9,"dur":1.8,"name":"re.Pattern.sub","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177181.5,"dur":3.22,"name":"sub (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\re.py:203)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177184.9,"dur":0.1,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177181.0,"dur":4.02,"name":"len_without_color_maker (D:\\githubs\\DR\\libs\\utils\\py_logger.py:465)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177185.6,"dur":0.2,"name":"dict.copy","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177186.1,"dur":0.7,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177187.6,"dur":0.1,"name":"nt.fspath","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177188.1,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177187.9,"dur":0.4,"name":"_get_bothseps (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:34)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177190.2,"dur":0.1,"name":"nt.fspath","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177190.4,"dur":0.02,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177190.6,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177190.8,"dur":0.2,"name":"str.replace","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177190.1,"dur":1.7,"name":"splitdrive (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:124)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177192.0,"dur":0.02,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177193.4,"dur":0.1,"name":"str.rstrip","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177187.4,"dur":6.4,"name":"split (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:180)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177194.5,"dur":0.4,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177195.7,"dur":0.2,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177196.3,"dur":0.3,"name":"time.time","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177197.7,"dur":0.1,"name":"dict.items","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177198.1,"dur":0.02,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177198.4,"dur":0.02,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177198.6,"dur":0.02,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177198.7,"dur":0.02,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177199.0,"dur":0.3,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177199.6,"dur":0.3,"name":"str.find","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177200.1,"dur":0.1,"name":"str.find","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177200.4,"dur":0.1,"name":"str.replace","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177200.52,"dur":6.88,"name":"time.strftime","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177207.8,"dur":0.02,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177208.0,"dur":0.4,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177208.5,"dur":0.2,"name":"str.find","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177208.8,"dur":0.1,"name":"str.find","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177209.0,"dur":0.1,"name":"str.replace","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177209.2,"dur":3.9,"name":"time.strftime","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177213.4,"dur":0.02,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177213.5,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177214.8,"dur":1.4,"name":"str.format","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177180.1,"dur":36.3,"name":"format_text (D:\\githubs\\DR\\libs\\utils\\py_logger.py:371)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177216.8,"dur":35.0,"name":"builtins.print","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177175.9,"dur":76.4,"name":"make_log (D:\\githubs\\DR\\libs\\utils\\py_logger.py:348)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177175.1,"dur":77.8,"name":"error (D:\\githubs\\DR\\libs\\utils\\py_logger.py:428)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177255.0,"dur":0.2,"name":"builtins.hasattr","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177255.3,"dur":0.2,"name":"sys._getframe","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177254.8,"dur":0.72,"name":"currentframe (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\inspect.py:1520)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177256.9,"dur":0.4,"name":"<genexpr> (D:\\githubs\\DR\\libs\\utils\\py_logger.py:360)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177257.32,"dur":0.08,"name":"<genexpr> (D:\\githubs\\DR\\libs\\utils\\py_logger.py:360)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177256.6,"dur":1.1,"name":"str.join","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177258.6,"dur":0.1,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177260.0,"dur":0.3,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177259.8,"dur":1.0,"name":"_compile (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\re.py:289)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177261.0,"dur":1.9,"name":"re.Pattern.sub","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177259.5,"dur":3.5,"name":"sub (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\re.py:203)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177263.2,"dur":0.1,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177259.1,"dur":4.3,"name":"len_without_color_maker (D:\\githubs\\DR\\libs\\utils\\py_logger.py:465)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177265.5,"dur":0.2,"name":"dict.copy","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177266.1,"dur":0.7,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177267.6,"dur":0.1,"name":"nt.fspath","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177268.1,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177268.0,"dur":0.3,"name":"_get_bothseps (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:34)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177268.7,"dur":0.02,"name":"nt.fspath","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177268.8,"dur":0.1,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177269.0,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177269.2,"dur":0.2,"name":"str.replace","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177268.5,"dur":1.7,"name":"splitdrive (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:124)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177270.3,"dur":0.1,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177271.8,"dur":0.1,"name":"str.rstrip","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177267.4,"dur":4.8,"name":"split (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:180)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177272.8,"dur":0.3,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177273.9,"dur":0.3,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177274.6,"dur":0.2,"name":"time.time","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177275.9,"dur":0.1,"name":"dict.items","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177276.3,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177276.6,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177276.8,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177277.0,"dur":0.02,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177277.3,"dur":0.3,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177277.8,"dur":0.3,"name":"str.find","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177278.3,"dur":0.1,"name":"str.find","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177278.6,"dur":0.1,"name":"str.replace","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177278.8,"dur":6.8,"name":"time.strftime","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177285.9,"dur":0.02,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177286.2,"dur":0.2,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177286.5,"dur":0.2,"name":"str.find","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177286.8,"dur":0.1,"name":"str.find","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177287.0,"dur":0.1,"name":"str.replace","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177287.2,"dur":3.8,"name":"time.strftime","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177291.3,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177291.5,"dur":0.02,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177292.7,"dur":1.5,"name":"str.format","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177258.3,"dur":36.0,"name":"format_text (D:\\githubs\\DR\\libs\\utils\\py_logger.py:371)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177294.8,"dur":34.7,"name":"builtins.print","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177254.2,"dur":75.7,"name":"make_log (D:\\githubs\\DR\\libs\\utils\\py_logger.py:348)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177253.6,"dur":76.9,"name":"fatal (D:\\githubs\\DR\\libs\\utils\\py_logger.py:436)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253176764.9,"dur":565.8,"name":"test_logger (D:\\githubs\\DR\\libs\\utils\\py_logger.py:571)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177331.2,"dur":26.6,"name":"builtins.print","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177361.6,"dur":0.3,"name":"builtins.hasattr","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177362.0,"dur":0.1,"name":"sys._getframe","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177361.4,"dur":0.8,"name":"currentframe (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\inspect.py:1520)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177366.6,"dur":0.4,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177366.5,"dur":1.2,"name":"_compile (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\re.py:289)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177369.6,"dur":2.1,"name":"re.Pattern.sub","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177366.1,"dur":5.7,"name":"sub (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\re.py:203)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177375.5,"dur":0.1,"name":"nt.fspath","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177376.0,"dur":0.2,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177375.9,"dur":0.4,"name":"_get_bothseps (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:34)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177376.6,"dur":0.1,"name":"nt.fspath","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177376.8,"dur":0.1,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177377.0,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177377.3,"dur":0.1,"name":"str.replace","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177376.5,"dur":1.7,"name":"splitdrive (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:124)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177378.4,"dur":0.02,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177380.1,"dur":0.2,"name":"str.rstrip","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177375.3,"dur":5.2,"name":"split (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:180)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177443.1,"dur":0.2,"name":"builtins.hasattr","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177443.5,"dur":0.2,"name":"sys._getframe","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177442.8,"dur":1.0,"name":"currentframe (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\inspect.py:1520)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177447.3,"dur":0.5,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177447.1,"dur":1.4,"name":"_compile (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\re.py:289)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177448.7,"dur":1.8,"name":"re.Pattern.sub","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177446.8,"dur":3.8,"name":"sub (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\re.py:203)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177453.5,"dur":0.1,"name":"nt.fspath","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177454.1,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177453.9,"dur":0.4,"name":"_get_bothseps (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:34)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177454.8,"dur":0.02,"name":"nt.fspath","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177454.9,"dur":0.1,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177455.2,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177455.5,"dur":0.1,"name":"str.replace","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177454.6,"dur":1.8,"name":"splitdrive (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:124)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177456.6,"dur":0.1,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177458.2,"dur":0.2,"name":"str.rstrip","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177453.3,"dur":5.4,"name":"split (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:180)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177518.2,"dur":0.2,"name":"builtins.hasattr","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177518.6,"dur":0.2,"name":"sys._getframe","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177517.9,"dur":1.0,"name":"currentframe (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\inspect.py:1520)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177522.1,"dur":0.4,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177521.9,"dur":1.2,"name":"_compile (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\re.py:289)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177523.3,"dur":1.9,"name":"re.Pattern.sub","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177521.5,"dur":3.8,"name":"sub (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\re.py:203)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177528.1,"dur":0.1,"name":"nt.fspath","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177528.7,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177528.5,"dur":0.4,"name":"_get_bothseps (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:34)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177529.3,"dur":0.02,"name":"nt.fspath","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177529.4,"dur":0.1,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177529.7,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177529.9,"dur":0.2,"name":"str.replace","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177529.1,"dur":1.7,"name":"splitdrive (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:124)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177531.0,"dur":0.1,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177534.5,"dur":0.1,"name":"str.rstrip","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177527.9,"dur":7.0,"name":"split (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:180)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177593.6,"dur":0.2,"name":"builtins.hasattr","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177594.0,"dur":0.2,"name":"sys._getframe","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177593.4,"dur":0.82,"name":"currentframe (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\inspect.py:1520)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177597.5,"dur":0.4,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177597.4,"dur":1.2,"name":"_compile (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\re.py:289)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177598.9,"dur":1.8,"name":"re.Pattern.sub","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177597.0,"dur":3.8,"name":"sub (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\re.py:203)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177603.6,"dur":0.1,"name":"nt.fspath","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177604.2,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177604.0,"dur":0.5,"name":"_get_bothseps (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:34)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177604.9,"dur":0.02,"name":"nt.fspath","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177605.0,"dur":0.1,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177605.3,"dur":0.02,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177605.5,"dur":0.2,"name":"str.replace","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177604.7,"dur":1.8,"name":"splitdrive (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:124)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177606.8,"dur":0.02,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177608.4,"dur":0.2,"name":"str.rstrip","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177603.4,"dur":5.5,"name":"split (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:180)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177668.0,"dur":0.3,"name":"builtins.hasattr","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177668.4,"dur":0.2,"name":"sys._getframe","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177667.8,"dur":0.9,"name":"currentframe (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\inspect.py:1520)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177671.8,"dur":0.4,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177671.6,"dur":1.2,"name":"_compile (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\re.py:289)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177673.1,"dur":1.7,"name":"re.Pattern.sub","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177671.3,"dur":3.6,"name":"sub (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\re.py:203)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177677.7,"dur":0.1,"name":"nt.fspath","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177678.2,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177678.1,"dur":0.3,"name":"_get_bothseps (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:34)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177678.8,"dur":0.02,"name":"nt.fspath","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177678.9,"dur":0.1,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177679.2,"dur":0.02,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177679.4,"dur":0.1,"name":"str.replace","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177678.7,"dur":1.6,"name":"splitdrive (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:124)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177680.5,"dur":0.02,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177682.2,"dur":0.1,"name":"str.rstrip","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177677.5,"dur":5.1,"name":"split (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:180)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177744.3,"dur":0.4,"name":"builtins.hasattr","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177744.9,"dur":0.3,"name":"sys._getframe","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177743.8,"dur":1.5,"name":"currentframe (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\inspect.py:1520)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177749.5,"dur":0.7,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177749.3,"dur":1.9,"name":"_compile (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\re.py:289)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177751.5,"dur":2.6,"name":"re.Pattern.sub","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177748.8,"dur":5.5,"name":"sub (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\re.py:203)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177757.9,"dur":0.1,"name":"nt.fspath","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177760.9,"dur":0.2,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177760.7,"dur":0.5,"name":"_get_bothseps (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:34)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177761.7,"dur":0.1,"name":"nt.fspath","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177761.9,"dur":0.1,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177762.2,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177762.5,"dur":0.2,"name":"str.replace","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177761.6,"dur":2.1,"name":"splitdrive (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:124)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177763.9,"dur":0.02,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177765.6,"dur":0.2,"name":"str.rstrip","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177757.7,"dur":8.4,"name":"split (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:180)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177830.1,"dur":0.2,"name":"builtins.hasattr","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177830.5,"dur":0.1,"name":"sys._getframe","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177829.8,"dur":0.9,"name":"currentframe (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\inspect.py:1520)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177833.9,"dur":0.4,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177833.7,"dur":1.3,"name":"_compile (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\re.py:289)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177835.2,"dur":2.1,"name":"re.Pattern.sub","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177833.4,"dur":4.0,"name":"sub (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\re.py:203)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177840.3,"dur":0.1,"name":"nt.fspath","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177840.9,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177840.7,"dur":0.4,"name":"_get_bothseps (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:34)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177841.5,"dur":0.02,"name":"nt.fspath","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177841.6,"dur":0.1,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177841.9,"dur":0.02,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177842.1,"dur":0.2,"name":"str.replace","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177841.4,"dur":1.6,"name":"splitdrive (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:124)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177843.2,"dur":0.02,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177844.8,"dur":0.1,"name":"str.rstrip","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177840.1,"dur":5.0,"name":"split (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:180)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177358.7,"dur":543.7,"name":"test_logger (D:\\githubs\\DR\\libs\\utils\\py_logger.py:571)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177903.1,"dur":26.7,"name":"builtins.print","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177933.4,"dur":0.2,"name":"builtins.hasattr","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177933.7,"dur":0.2,"name":"sys._getframe","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177933.2,"dur":0.8,"name":"currentframe (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\inspect.py:1520)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177935.5,"dur":0.6,"name":"<genexpr> (D:\\githubs\\DR\\libs\\utils\\py_logger.py:360)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177936.12,"dur":0.18,"name":"<genexpr> (D:\\githubs\\DR\\libs\\utils\\py_logger.py:360)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177935.2,"dur":1.5,"name":"str.join","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177937.8,"dur":0.1,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177939.4,"dur":0.4,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177939.2,"dur":1.1,"name":"_compile (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\re.py:289)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177940.5,"dur":2.0,"name":"re.Pattern.sub","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177939.0,"dur":3.6,"name":"sub (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\re.py:203)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177942.7,"dur":0.1,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177938.5,"dur":4.4,"name":"len_without_color_maker (D:\\githubs\\DR\\libs\\utils\\py_logger.py:465)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177943.6,"dur":0.1,"name":"dict.copy","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177944.1,"dur":0.7,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177945.8,"dur":0.1,"name":"nt.fspath","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177946.3,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177946.2,"dur":2.3,"name":"_get_bothseps (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:34)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177948.8,"dur":0.1,"name":"nt.fspath","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177949.0,"dur":0.02,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177949.2,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177949.5,"dur":0.1,"name":"str.replace","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177948.7,"dur":1.7,"name":"splitdrive (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:124)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177950.5,"dur":0.1,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177952.1,"dur":0.2,"name":"str.rstrip","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177945.6,"dur":6.9,"name":"split (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:180)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177953.3,"dur":0.3,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177954.5,"dur":0.2,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177955.2,"dur":0.2,"name":"time.time","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177956.7,"dur":0.1,"name":"dict.items","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177957.1,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177957.5,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177957.7,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177957.82,"dur":0.08,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177958.3,"dur":0.3,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177958.9,"dur":0.4,"name":"str.find","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177959.5,"dur":0.1,"name":"str.find","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177959.8,"dur":0.2,"name":"str.replace","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177960.02,"dur":7.18,"name":"time.strftime","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177967.6,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177968.0,"dur":0.3,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177968.5,"dur":0.1,"name":"str.find","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177968.7,"dur":0.1,"name":"str.find","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177968.9,"dur":0.1,"name":"str.replace","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177969.1,"dur":3.9,"name":"time.strftime","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177973.4,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177973.52,"dur":0.08,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177974.9,"dur":1.6,"name":"str.format","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177937.5,"dur":39.3,"name":"format_text (D:\\githubs\\DR\\libs\\utils\\py_logger.py:371)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177977.4,"dur":34.9,"name":"builtins.print","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177932.6,"dur":80.3,"name":"make_log (D:\\githubs\\DR\\libs\\utils\\py_logger.py:348)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177931.5,"dur":82.0,"name":"trace (D:\\githubs\\DR\\libs\\utils\\py_logger.py:390)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178016.0,"dur":0.2,"name":"builtins.hasattr","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178016.3,"dur":0.1,"name":"sys._getframe","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178015.8,"dur":0.7,"name":"currentframe (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\inspect.py:1520)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178017.9,"dur":0.3,"name":"<genexpr> (D:\\githubs\\DR\\libs\\utils\\py_logger.py:360)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178018.3,"dur":0.1,"name":"<genexpr> (D:\\githubs\\DR\\libs\\utils\\py_logger.py:360)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178017.6,"dur":1.1,"name":"str.join","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178019.6,"dur":0.1,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178021.0,"dur":0.3,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178020.8,"dur":1.0,"name":"_compile (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\re.py:289)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178022.0,"dur":1.8,"name":"re.Pattern.sub","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178020.5,"dur":3.32,"name":"sub (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\re.py:203)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178025.4,"dur":0.1,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178020.1,"dur":5.5,"name":"len_without_color_maker (D:\\githubs\\DR\\libs\\utils\\py_logger.py:465)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178026.3,"dur":0.1,"name":"dict.copy","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178026.8,"dur":0.6,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178028.4,"dur":0.1,"name":"nt.fspath","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178028.9,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178028.7,"dur":0.4,"name":"_get_bothseps (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:34)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178029.5,"dur":0.02,"name":"nt.fspath","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178029.6,"dur":0.1,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178029.8,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178030.0,"dur":0.2,"name":"str.replace","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178029.4,"dur":1.5,"name":"splitdrive (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:124)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178031.1,"dur":0.1,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178032.7,"dur":0.1,"name":"str.rstrip","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178028.2,"dur":4.8,"name":"split (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:180)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178033.6,"dur":0.3,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178034.7,"dur":0.2,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178035.3,"dur":0.3,"name":"time.time","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178036.9,"dur":0.1,"name":"dict.items","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178037.3,"dur":0.02,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178037.6,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178037.8,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178037.92,"dur":0.08,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178038.3,"dur":0.3,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178038.8,"dur":0.3,"name":"str.find","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178039.3,"dur":0.1,"name":"str.find","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178039.6,"dur":0.1,"name":"str.replace","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178039.8,"dur":7.0,"name":"time.strftime","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178047.1,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178047.4,"dur":0.3,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178047.8,"dur":0.1,"name":"str.find","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178048.1,"dur":0.1,"name":"str.find","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178048.3,"dur":0.1,"name":"str.replace","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178048.5,"dur":3.9,"name":"time.strftime","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178052.7,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178052.9,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178054.1,"dur":1.5,"name":"str.format","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178019.3,"dur":36.5,"name":"format_text (D:\\githubs\\DR\\libs\\utils\\py_logger.py:371)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178056.3,"dur":34.3,"name":"builtins.print","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178015.2,"dur":75.8,"name":"make_log (D:\\githubs\\DR\\libs\\utils\\py_logger.py:348)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178014.5,"dur":77.2,"name":"fine (D:\\githubs\\DR\\libs\\utils\\py_logger.py:397)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178094.0,"dur":0.2,"name":"builtins.hasattr","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178094.3,"dur":0.2,"name":"sys._getframe","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178093.9,"dur":0.62,"name":"currentframe (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\inspect.py:1520)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178095.9,"dur":0.3,"name":"<genexpr> (D:\\githubs\\DR\\libs\\utils\\py_logger.py:360)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178096.3,"dur":0.1,"name":"<genexpr> (D:\\githubs\\DR\\libs\\utils\\py_logger.py:360)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178095.6,"dur":1.1,"name":"str.join","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178099.0,"dur":0.1,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178100.4,"dur":0.3,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178100.2,"dur":1.0,"name":"_compile (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\re.py:289)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178101.5,"dur":1.8,"name":"re.Pattern.sub","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178100.0,"dur":3.4,"name":"sub (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\re.py:203)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178103.5,"dur":0.1,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178099.5,"dur":4.2,"name":"len_without_color_maker (D:\\githubs\\DR\\libs\\utils\\py_logger.py:465)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178104.3,"dur":0.2,"name":"dict.copy","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178104.8,"dur":0.7,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178106.3,"dur":0.2,"name":"nt.fspath","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178106.9,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178106.7,"dur":0.32,"name":"_get_bothseps (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:34)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178107.5,"dur":0.02,"name":"nt.fspath","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178107.6,"dur":0.02,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178107.8,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178108.0,"dur":0.2,"name":"str.replace","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178107.3,"dur":1.5,"name":"splitdrive (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:124)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178109.0,"dur":0.1,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178110.5,"dur":0.2,"name":"str.rstrip","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178106.2,"dur":4.7,"name":"split (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:180)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178111.5,"dur":0.3,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178112.6,"dur":0.2,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178113.2,"dur":0.2,"name":"time.time","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178114.7,"dur":0.1,"name":"dict.items","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178115.1,"dur":0.02,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178115.4,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178115.6,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178115.72,"dur":0.08,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178116.1,"dur":0.3,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178116.6,"dur":0.3,"name":"str.find","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178117.1,"dur":0.1,"name":"str.find","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178117.4,"dur":0.1,"name":"str.replace","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178117.6,"dur":6.9,"name":"time.strftime","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178124.8,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178125.1,"dur":0.3,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178125.6,"dur":0.1,"name":"str.find","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178125.8,"dur":0.1,"name":"str.find","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178126.1,"dur":0.1,"name":"str.replace","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178126.22,"dur":4.38,"name":"time.strftime","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178130.9,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178131.1,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178132.2,"dur":1.5,"name":"str.format","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178098.7,"dur":35.1,"name":"format_text (D:\\githubs\\DR\\libs\\utils\\py_logger.py:371)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178134.3,"dur":38.8,"name":"builtins.print","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178093.3,"dur":80.3,"name":"make_log (D:\\githubs\\DR\\libs\\utils\\py_logger.py:348)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178092.6,"dur":81.6,"name":"debug (D:\\githubs\\DR\\libs\\utils\\py_logger.py:404)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178176.4,"dur":0.2,"name":"builtins.hasattr","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178178.0,"dur":0.1,"name":"sys._getframe","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178176.3,"dur":1.9,"name":"currentframe (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\inspect.py:1520)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178179.6,"dur":0.4,"name":"<genexpr> (D:\\githubs\\DR\\libs\\utils\\py_logger.py:360)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178180.02,"dur":0.18,"name":"<genexpr> (D:\\githubs\\DR\\libs\\utils\\py_logger.py:360)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178179.3,"dur":1.2,"name":"str.join","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178181.3,"dur":0.1,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178182.7,"dur":0.3,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178182.5,"dur":1.0,"name":"_compile (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\re.py:289)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178183.7,"dur":1.8,"name":"re.Pattern.sub","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178182.3,"dur":3.3,"name":"sub (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\re.py:203)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178185.7,"dur":0.1,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178181.8,"dur":4.02,"name":"len_without_color_maker (D:\\githubs\\DR\\libs\\utils\\py_logger.py:465)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178186.5,"dur":0.2,"name":"dict.copy","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178187.1,"dur":0.7,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178188.6,"dur":0.1,"name":"nt.fspath","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178189.1,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178189.0,"dur":0.3,"name":"_get_bothseps (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:34)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178189.7,"dur":0.02,"name":"nt.fspath","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178189.8,"dur":0.1,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178190.0,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178190.2,"dur":0.1,"name":"str.replace","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178189.5,"dur":1.5,"name":"splitdrive (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:124)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178191.2,"dur":0.02,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178192.8,"dur":0.1,"name":"str.rstrip","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178188.4,"dur":4.7,"name":"split (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:180)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178193.7,"dur":0.3,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178194.8,"dur":0.3,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178195.5,"dur":0.2,"name":"time.time","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178196.9,"dur":0.1,"name":"dict.items","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178197.3,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178197.6,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178197.8,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178197.92,"dur":0.08,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178198.3,"dur":0.3,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178198.8,"dur":0.3,"name":"str.find","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178199.3,"dur":0.1,"name":"str.find","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178199.6,"dur":0.1,"name":"str.replace","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178199.72,"dur":6.98,"name":"time.strftime","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178207.0,"dur":0.02,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178207.3,"dur":0.3,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178207.7,"dur":0.1,"name":"str.find","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178207.9,"dur":0.1,"name":"str.find","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178208.2,"dur":0.1,"name":"str.replace","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178208.4,"dur":4.0,"name":"time.strftime","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178212.6,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178212.8,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178215.1,"dur":1.4,"name":"str.format","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178181.0,"dur":35.7,"name":"format_text (D:\\githubs\\DR\\libs\\utils\\py_logger.py:371)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178217.2,"dur":38.3,"name":"builtins.print","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178175.7,"dur":80.3,"name":"make_log (D:\\githubs\\DR\\libs\\utils\\py_logger.py:348)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178175.0,"dur":81.7,"name":"info (D:\\githubs\\DR\\libs\\utils\\py_logger.py:412)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178258.9,"dur":0.3,"name":"builtins.hasattr","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178259.3,"dur":0.1,"name":"sys._getframe","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178258.8,"dur":0.7,"name":"currentframe (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\inspect.py:1520)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178260.8,"dur":0.4,"name":"<genexpr> (D:\\githubs\\DR\\libs\\utils\\py_logger.py:360)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178261.22,"dur":0.18,"name":"<genexpr> (D:\\githubs\\DR\\libs\\utils\\py_logger.py:360)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178260.5,"dur":1.2,"name":"str.join","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178262.5,"dur":0.1,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178264.0,"dur":0.3,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178263.8,"dur":0.9,"name":"_compile (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\re.py:289)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178264.9,"dur":1.6,"name":"re.Pattern.sub","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178263.5,"dur":3.1,"name":"sub (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\re.py:203)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178266.8,"dur":0.02,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178263.1,"dur":3.8,"name":"len_without_color_maker (D:\\githubs\\DR\\libs\\utils\\py_logger.py:465)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178267.5,"dur":0.2,"name":"dict.copy","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178268.0,"dur":0.6,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178269.5,"dur":0.1,"name":"nt.fspath","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178270.0,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178269.9,"dur":0.22,"name":"_get_bothseps (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:34)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178270.5,"dur":0.02,"name":"nt.fspath","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178270.6,"dur":0.1,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178270.8,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178271.0,"dur":0.1,"name":"str.replace","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178270.4,"dur":1.4,"name":"splitdrive (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:124)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178272.1,"dur":0.02,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178273.5,"dur":0.1,"name":"str.rstrip","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178269.3,"dur":4.6,"name":"split (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:180)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178274.5,"dur":0.4,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178275.7,"dur":0.2,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178276.3,"dur":0.2,"name":"time.time","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178277.7,"dur":0.1,"name":"dict.items","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178278.1,"dur":0.02,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178278.3,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178278.5,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178278.7,"dur":0.02,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178279.0,"dur":0.3,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178279.6,"dur":0.3,"name":"str.find","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178280.0,"dur":0.1,"name":"str.find","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178280.3,"dur":0.1,"name":"str.replace","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178280.5,"dur":6.9,"name":"time.strftime","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178287.8,"dur":0.02,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178288.1,"dur":0.3,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178288.5,"dur":0.1,"name":"str.find","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178290.1,"dur":0.1,"name":"str.find","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178290.4,"dur":0.1,"name":"str.replace","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178290.6,"dur":3.9,"name":"time.strftime","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178294.8,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178295.0,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178296.1,"dur":1.5,"name":"str.format","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178262.2,"dur":35.5,"name":"format_text (D:\\githubs\\DR\\libs\\utils\\py_logger.py:371)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178298.2,"dur":40.1,"name":"builtins.print","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178258.3,"dur":80.7,"name":"make_log (D:\\githubs\\DR\\libs\\utils\\py_logger.py:348)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178257.6,"dur":82.1,"name":"warning (D:\\githubs\\DR\\libs\\utils\\py_logger.py:420)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178343.0,"dur":0.3,"name":"builtins.hasattr","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178343.4,"dur":0.2,"name":"sys._getframe","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178342.8,"dur":0.9,"name":"currentframe (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\inspect.py:1520)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178345.5,"dur":0.5,"name":"<genexpr> (D:\\githubs\\DR\\libs\\utils\\py_logger.py:360)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178346.1,"dur":0.2,"name":"<genexpr> (D:\\githubs\\DR\\libs\\utils\\py_logger.py:360)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178345.1,"dur":1.6,"name":"str.join","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178347.9,"dur":0.1,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178349.5,"dur":0.4,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178349.3,"dur":1.2,"name":"_compile (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\re.py:289)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178350.7,"dur":2.0,"name":"re.Pattern.sub","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178349.0,"dur":3.8,"name":"sub (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\re.py:203)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178353.0,"dur":0.1,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178348.5,"dur":4.62,"name":"len_without_color_maker (D:\\githubs\\DR\\libs\\utils\\py_logger.py:465)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178354.0,"dur":0.2,"name":"dict.copy","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178354.6,"dur":0.8,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178356.5,"dur":0.1,"name":"nt.fspath","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178357.0,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178356.9,"dur":0.4,"name":"_get_bothseps (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:34)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178357.7,"dur":0.02,"name":"nt.fspath","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178357.8,"dur":0.02,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178358.0,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178358.3,"dur":0.1,"name":"str.replace","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178357.5,"dur":1.8,"name":"splitdrive (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:124)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178359.5,"dur":0.1,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178361.2,"dur":0.1,"name":"str.rstrip","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178356.3,"dur":5.2,"name":"split (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:180)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178362.4,"dur":0.4,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178363.7,"dur":0.3,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178364.5,"dur":0.2,"name":"time.time","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178366.0,"dur":0.2,"name":"dict.items","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178366.5,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178366.8,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178367.0,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178367.2,"dur":0.02,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178367.6,"dur":0.4,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178368.3,"dur":0.3,"name":"str.find","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178370.6,"dur":0.2,"name":"str.find","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178371.0,"dur":0.1,"name":"str.replace","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178371.3,"dur":5.4,"name":"time.strftime","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178377.2,"dur":0.02,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178377.5,"dur":0.4,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178378.1,"dur":0.1,"name":"str.find","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178378.3,"dur":0.1,"name":"str.find","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178378.6,"dur":0.1,"name":"str.replace","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178378.8,"dur":3.9,"name":"time.strftime","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178383.0,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178383.2,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178384.7,"dur":1.7,"name":"str.format","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178347.5,"dur":39.1,"name":"format_text (D:\\githubs\\DR\\libs\\utils\\py_logger.py:371)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178387.1,"dur":42.7,"name":"builtins.print","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178342.0,"dur":88.6,"name":"make_log (D:\\githubs\\DR\\libs\\utils\\py_logger.py:348)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178341.0,"dur":90.3,"name":"error (D:\\githubs\\DR\\libs\\utils\\py_logger.py:428)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178434.7,"dur":0.3,"name":"builtins.hasattr","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178435.2,"dur":0.2,"name":"sys._getframe","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178434.5,"dur":0.92,"name":"currentframe (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\inspect.py:1520)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178437.1,"dur":0.5,"name":"<genexpr> (D:\\githubs\\DR\\libs\\utils\\py_logger.py:360)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178437.7,"dur":0.2,"name":"<genexpr> (D:\\githubs\\DR\\libs\\utils\\py_logger.py:360)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178436.8,"dur":1.4,"name":"str.join","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178439.2,"dur":0.2,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178440.9,"dur":0.4,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178440.8,"dur":1.1,"name":"_compile (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\re.py:289)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178442.2,"dur":2.4,"name":"re.Pattern.sub","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178440.5,"dur":4.3,"name":"sub (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\re.py:203)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178445.0,"dur":0.1,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178439.9,"dur":5.22,"name":"len_without_color_maker (D:\\githubs\\DR\\libs\\utils\\py_logger.py:465)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178445.9,"dur":0.3,"name":"dict.copy","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178446.6,"dur":0.8,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178448.4,"dur":0.2,"name":"nt.fspath","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178449.0,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178448.8,"dur":0.32,"name":"_get_bothseps (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:34)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178449.5,"dur":0.1,"name":"nt.fspath","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178449.62,"dur":0.08,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178449.9,"dur":0.02,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178450.1,"dur":0.2,"name":"str.replace","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178449.4,"dur":1.7,"name":"splitdrive (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:124)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178451.3,"dur":0.1,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178452.9,"dur":0.2,"name":"str.rstrip","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178448.2,"dur":5.1,"name":"split (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:180)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178454.1,"dur":0.3,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178455.2,"dur":0.3,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178455.8,"dur":0.3,"name":"time.time","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178457.5,"dur":0.2,"name":"dict.items","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178457.9,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178460.2,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178460.4,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178460.6,"dur":0.02,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178460.9,"dur":0.4,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178461.5,"dur":0.4,"name":"str.find","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178462.0,"dur":0.2,"name":"str.find","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178462.3,"dur":0.2,"name":"str.replace","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178462.6,"dur":6.0,"name":"time.strftime","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178469.0,"dur":0.02,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178469.3,"dur":0.2,"name":"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178469.7,"dur":0.1,"name":"str.find","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178469.9,"dur":0.1,"name":"str.find","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178470.2,"dur":0.2,"name":"str.replace","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178470.5,"dur":4.1,"name":"time.strftime","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178474.9,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178475.1,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178476.5,"dur":1.8,"name":"str.format","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178438.9,"dur":39.6,"name":"format_text (D:\\githubs\\DR\\libs\\utils\\py_logger.py:371)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178479.1,"dur":42.1,"name":"builtins.print","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178433.7,"dur":88.0,"name":"make_log (D:\\githubs\\DR\\libs\\utils\\py_logger.py:348)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178432.6,"dur":89.7,"name":"fatal (D:\\githubs\\DR\\libs\\utils\\py_logger.py:436)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253177930.4,"dur":592.3,"name":"utils.logger.test_logger","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178523.2,"dur":29.9,"name":"builtins.print","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178556.9,"dur":0.2,"name":"builtins.hasattr","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178557.3,"dur":0.2,"name":"sys._getframe","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178556.6,"dur":0.92,"name":"currentframe (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\inspect.py:1520)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178561.7,"dur":0.4,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178561.5,"dur":1.4,"name":"_compile (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\re.py:289)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178563.2,"dur":2.1,"name":"re.Pattern.sub","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178561.2,"dur":4.12,"name":"sub (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\re.py:203)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178569.0,"dur":0.1,"name":"nt.fspath","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178569.6,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178569.5,"dur":0.3,"name":"_get_bothseps (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:34)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178570.2,"dur":0.1,"name":"nt.fspath","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178570.4,"dur":0.1,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178570.7,"dur":0.02,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178570.9,"dur":0.2,"name":"str.replace","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178570.1,"dur":1.9,"name":"splitdrive (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:124)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178572.2,"dur":0.02,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178573.9,"dur":0.1,"name":"str.rstrip","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178568.8,"dur":5.5,"name":"split (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:180)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178639.2,"dur":0.3,"name":"builtins.hasattr","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178639.8,"dur":0.1,"name":"sys._getframe","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178638.8,"dur":1.2,"name":"currentframe (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\inspect.py:1520)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178643.4,"dur":0.5,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178643.2,"dur":1.5,"name":"_compile (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\re.py:289)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178646.8,"dur":2.1,"name":"re.Pattern.sub","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178642.8,"dur":6.2,"name":"sub (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\re.py:203)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178652.1,"dur":0.1,"name":"nt.fspath","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178652.7,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178652.5,"dur":0.4,"name":"_get_bothseps (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:34)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178653.4,"dur":0.02,"name":"nt.fspath","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178653.6,"dur":0.1,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178653.9,"dur":0.02,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178654.1,"dur":0.2,"name":"str.replace","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178653.3,"dur":1.8,"name":"splitdrive (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:124)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178655.3,"dur":0.02,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178656.9,"dur":0.2,"name":"str.rstrip","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178651.9,"dur":5.4,"name":"split (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:180)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178720.6,"dur":0.3,"name":"builtins.hasattr","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178721.1,"dur":0.1,"name":"sys._getframe","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178720.2,"dur":1.2,"name":"currentframe (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\inspect.py:1520)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178724.6,"dur":0.4,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178724.4,"dur":1.4,"name":"_compile (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\re.py:289)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178726.1,"dur":5.2,"name":"re.Pattern.sub","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178724.1,"dur":7.4,"name":"sub (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\re.py:203)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178734.4,"dur":0.1,"name":"nt.fspath","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178735.0,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178734.8,"dur":0.4,"name":"_get_bothseps (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:34)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178735.6,"dur":0.1,"name":"nt.fspath","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178735.8,"dur":0.02,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178736.0,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178736.2,"dur":0.1,"name":"str.replace","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178735.5,"dur":1.6,"name":"splitdrive (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:124)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178737.3,"dur":0.02,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178738.9,"dur":0.1,"name":"str.rstrip","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178734.2,"dur":5.1,"name":"split (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:180)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178801.0,"dur":0.3,"name":"builtins.hasattr","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178801.5,"dur":0.2,"name":"sys._getframe","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178800.7,"dur":1.1,"name":"currentframe (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\inspect.py:1520)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178805.1,"dur":0.5,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178804.9,"dur":1.4,"name":"_compile (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\re.py:289)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178806.5,"dur":1.8,"name":"re.Pattern.sub","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178804.5,"dur":4.0,"name":"sub (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\re.py:203)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178811.3,"dur":0.1,"name":"nt.fspath","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178811.9,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178811.7,"dur":0.4,"name":"_get_bothseps (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:34)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178812.5,"dur":0.1,"name":"nt.fspath","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178812.7,"dur":0.1,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178812.9,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178813.2,"dur":0.1,"name":"str.replace","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178812.4,"dur":1.7,"name":"splitdrive (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:124)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178814.3,"dur":0.02,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178817.7,"dur":0.1,"name":"str.rstrip","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178811.1,"dur":7.0,"name":"split (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:180)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178879.3,"dur":0.2,"name":"builtins.hasattr","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178879.8,"dur":0.1,"name":"sys._getframe","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178878.9,"dur":1.1,"name":"currentframe (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\inspect.py:1520)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178883.3,"dur":0.4,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178883.1,"dur":1.3,"name":"_compile (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\re.py:289)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178884.6,"dur":1.8,"name":"re.Pattern.sub","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178882.7,"dur":3.8,"name":"sub (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\re.py:203)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178889.4,"dur":0.1,"name":"nt.fspath","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178889.9,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178889.8,"dur":0.3,"name":"_get_bothseps (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:34)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178890.5,"dur":0.1,"name":"nt.fspath","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178890.62,"dur":0.08,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178890.9,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178891.1,"dur":0.2,"name":"str.replace","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178890.4,"dur":1.6,"name":"splitdrive (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:124)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178892.2,"dur":0.1,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178893.9,"dur":0.1,"name":"str.rstrip","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178889.2,"dur":5.2,"name":"split (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:180)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178954.7,"dur":0.2,"name":"builtins.hasattr","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178955.1,"dur":0.2,"name":"sys._getframe","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178954.3,"dur":1.1,"name":"currentframe (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\inspect.py:1520)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178958.4,"dur":0.4,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178958.2,"dur":1.3,"name":"_compile (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\re.py:289)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178959.7,"dur":1.7,"name":"re.Pattern.sub","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178957.9,"dur":3.6,"name":"sub (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\re.py:203)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178964.2,"dur":0.1,"name":"nt.fspath","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178964.8,"dur":0.02,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178964.6,"dur":0.4,"name":"_get_bothseps (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:34)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178965.4,"dur":0.02,"name":"nt.fspath","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178965.5,"dur":0.1,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178965.8,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178966.0,"dur":0.2,"name":"str.replace","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178965.3,"dur":1.7,"name":"splitdrive (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:124)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178967.2,"dur":0.02,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178968.8,"dur":0.1,"name":"str.rstrip","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178964.0,"dur":5.2,"name":"split (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:180)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253179028.8,"dur":0.3,"name":"builtins.hasattr","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253179029.3,"dur":0.1,"name":"sys._getframe","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253179028.5,"dur":1.0,"name":"currentframe (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\inspect.py:1520)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253179032.6,"dur":0.4,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253179032.4,"dur":1.2,"name":"_compile (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\re.py:289)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253179033.9,"dur":1.9,"name":"re.Pattern.sub","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253179032.1,"dur":3.8,"name":"sub (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\re.py:203)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253179038.6,"dur":0.1,"name":"nt.fspath","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253179041.0,"dur":0.02,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253179040.8,"dur":0.3,"name":"_get_bothseps (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:34)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253179041.5,"dur":0.1,"name":"nt.fspath","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253179041.62,"dur":0.08,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253179041.9,"dur":0.1,"name":"builtins.isinstance","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253179042.2,"dur":0.1,"name":"str.replace","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253179041.4,"dur":1.7,"name":"splitdrive (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:124)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253179043.3,"dur":0.02,"name":"builtins.len","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253179044.9,"dur":0.1,"name":"str.rstrip","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253179038.4,"dur":6.9,"name":"split (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:180)","ph":"X","cat":"FEE"},{"pid":36076,"tid":18660,"ts":219253178553.7,"dur":549.9,"name":"utils.logger.test_logger","ph":"X","cat":"FEE"}],"viztracer_metadata":{"version":"0.15.3","overflow":false},"file_info":{"files":{"C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\inspect.py":["\"\"\"Get useful information from live Python objects.\n\nThis module encapsulates the interface provided by the internal special\nattributes (co_*, im_*, tb_*, etc.) in a friendlier fashion.\nIt also provides some help for examining source code and class layout.\n\nHere are some of the useful functions provided by this module:\n\n    ismodule(), isclass(), ismethod(), isfunction(), isgeneratorfunction(),\n        isgenerator(), istraceback(), isframe(), iscode(), isbuiltin(),\n        isroutine() - check object types\n    getmembers() - get members of an object that satisfy a given condition\n\n    getfile(), getsourcefile(), getsource() - find an object's source code\n    getdoc(), getcomments() - get documentation on an object\n    getmodule() - determine the module that an object came from\n    getclasstree() - arrange classes so as to represent their hierarchy\n\n    getargvalues(), getcallargs() - get info about function arguments\n    getfullargspec() - same, with support for Python 3 features\n    formatargvalues() - format an argument spec\n    getouterframes(), getinnerframes() - get info about frames\n    currentframe() - get the current stack frame\n    stack(), trace() - get info about frames on the stack or in a traceback\n\n    signature() - get a Signature object for the callable\n\"\"\"\n\n# This module is in the public domain.  No warranties.\n\n__author__ = ('Ka-Ping Yee <ping@lfw.org>',\n              'Yury Selivanov <yselivanov@sprymix.com>')\n\nimport abc\nimport dis\nimport collections.abc\nimport enum\nimport importlib.machinery\nimport itertools\nimport linecache\nimport os\nimport re\nimport sys\nimport tokenize\nimport token\nimport types\nimport warnings\nimport functools\nimport builtins\nfrom operator import attrgetter\nfrom collections import namedtuple, OrderedDict\n\n# Create constants for the compiler flags in Include/code.h\n# We try to get them from dis to avoid duplication\nmod_dict = globals()\nfor k, v in dis.COMPILER_FLAG_NAMES.items():\n    mod_dict[\"CO_\" + v] = k\n\n# See Include/object.h\nTPFLAGS_IS_ABSTRACT = 1 << 20\n\n# ----------------------------------------------------------- type-checking\ndef ismodule(object):\n    \"\"\"Return true if the object is a module.\n\n    Module objects provide these attributes:\n        __cached__      pathname to byte compiled file\n        __doc__         documentation string\n        __file__        filename (missing for built-in modules)\"\"\"\n    return isinstance(object, types.ModuleType)\n\ndef isclass(object):\n    \"\"\"Return true if the object is a class.\n\n    Class objects provide these attributes:\n        __doc__         documentation string\n        __module__      name of module in which this class was defined\"\"\"\n    return isinstance(object, type)\n\ndef ismethod(object):\n    \"\"\"Return true if the object is an instance method.\n\n    Instance method objects provide these attributes:\n        __doc__         documentation string\n        __name__        name with which this method was defined\n        __func__        function object containing implementation of method\n        __self__        instance to which this method is bound\"\"\"\n    return isinstance(object, types.MethodType)\n\ndef ismethoddescriptor(object):\n    \"\"\"Return true if the object is a method descriptor.\n\n    But not if ismethod() or isclass() or isfunction() are true.\n\n    This is new in Python 2.2, and, for example, is true of int.__add__.\n    An object passing this test has a __get__ attribute but not a __set__\n    attribute, but beyond that the set of attributes varies.  __name__ is\n    usually sensible, and __doc__ often is.\n\n    Methods implemented via descriptors that also pass one of the other\n    tests return false from the ismethoddescriptor() test, simply because\n    the other tests promise more -- you can, e.g., count on having the\n    __func__ attribute (etc) when an object passes ismethod().\"\"\"\n    if isclass(object) or ismethod(object) or isfunction(object):\n        # mutual exclusion\n        return False\n    tp = type(object)\n    return hasattr(tp, \"__get__\") and not hasattr(tp, \"__set__\")\n\ndef isdatadescriptor(object):\n    \"\"\"Return true if the object is a data descriptor.\n\n    Data descriptors have a __set__ or a __delete__ attribute.  Examples are\n    properties (defined in Python) and getsets and members (defined in C).\n    Typically, data descriptors will also have __name__ and __doc__ attributes\n    (properties, getsets, and members have both of these attributes), but this\n    is not guaranteed.\"\"\"\n    if isclass(object) or ismethod(object) or isfunction(object):\n        # mutual exclusion\n        return False\n    tp = type(object)\n    return hasattr(tp, \"__set__\") or hasattr(tp, \"__delete__\")\n\nif hasattr(types, 'MemberDescriptorType'):\n    # CPython and equivalent\n    def ismemberdescriptor(object):\n        \"\"\"Return true if the object is a member descriptor.\n\n        Member descriptors are specialized descriptors defined in extension\n        modules.\"\"\"\n        return isinstance(object, types.MemberDescriptorType)\nelse:\n    # Other implementations\n    def ismemberdescriptor(object):\n        \"\"\"Return true if the object is a member descriptor.\n\n        Member descriptors are specialized descriptors defined in extension\n        modules.\"\"\"\n        return False\n\nif hasattr(types, 'GetSetDescriptorType'):\n    # CPython and equivalent\n    def isgetsetdescriptor(object):\n        \"\"\"Return true if the object is a getset descriptor.\n\n        getset descriptors are specialized descriptors defined in extension\n        modules.\"\"\"\n        return isinstance(object, types.GetSetDescriptorType)\nelse:\n    # Other implementations\n    def isgetsetdescriptor(object):\n        \"\"\"Return true if the object is a getset descriptor.\n\n        getset descriptors are specialized descriptors defined in extension\n        modules.\"\"\"\n        return False\n\ndef isfunction(object):\n    \"\"\"Return true if the object is a user-defined function.\n\n    Function objects provide these attributes:\n        __doc__         documentation string\n        __name__        name with which this function was defined\n        __code__        code object containing compiled function bytecode\n        __defaults__    tuple of any default values for arguments\n        __globals__     global namespace in which this function was defined\n        __annotations__ dict of parameter annotations\n        __kwdefaults__  dict of keyword only parameters with defaults\"\"\"\n    return isinstance(object, types.FunctionType)\n\ndef _has_code_flag(f, flag):\n    \"\"\"Return true if ``f`` is a function (or a method or functools.partial\n    wrapper wrapping a function) whose code object has the given ``flag``\n    set in its flags.\"\"\"\n    while ismethod(f):\n        f = f.__func__\n    f = functools._unwrap_partial(f)\n    if not isfunction(f):\n        return False\n    return bool(f.__code__.co_flags & flag)\n\ndef isgeneratorfunction(obj):\n    \"\"\"Return true if the object is a user-defined generator function.\n\n    Generator function objects provide the same attributes as functions.\n    See help(isfunction) for a list of attributes.\"\"\"\n    return _has_code_flag(obj, CO_GENERATOR)\n\ndef iscoroutinefunction(obj):\n    \"\"\"Return true if the object is a coroutine function.\n\n    Coroutine functions are defined with \"async def\" syntax.\n    \"\"\"\n    return _has_code_flag(obj, CO_COROUTINE)\n\ndef isasyncgenfunction(obj):\n    \"\"\"Return true if the object is an asynchronous generator function.\n\n    Asynchronous generator functions are defined with \"async def\"\n    syntax and have \"yield\" expressions in their body.\n    \"\"\"\n    return _has_code_flag(obj, CO_ASYNC_GENERATOR)\n\ndef isasyncgen(object):\n    \"\"\"Return true if the object is an asynchronous generator.\"\"\"\n    return isinstance(object, types.AsyncGeneratorType)\n\ndef isgenerator(object):\n    \"\"\"Return true if the object is a generator.\n\n    Generator objects provide these attributes:\n        __iter__        defined to support iteration over container\n        close           raises a new GeneratorExit exception inside the\n                        generator to terminate the iteration\n        gi_code         code object\n        gi_frame        frame object or possibly None once the generator has\n                        been exhausted\n        gi_running      set to 1 when generator is executing, 0 otherwise\n        next            return the next item from the container\n        send            resumes the generator and \"sends\" a value that becomes\n                        the result of the current yield-expression\n        throw           used to raise an exception inside the generator\"\"\"\n    return isinstance(object, types.GeneratorType)\n\ndef iscoroutine(object):\n    \"\"\"Return true if the object is a coroutine.\"\"\"\n    return isinstance(object, types.CoroutineType)\n\ndef isawaitable(object):\n    \"\"\"Return true if object can be passed to an ``await`` expression.\"\"\"\n    return (isinstance(object, types.CoroutineType) or\n            isinstance(object, types.GeneratorType) and\n                bool(object.gi_code.co_flags & CO_ITERABLE_COROUTINE) or\n            isinstance(object, collections.abc.Awaitable))\n\ndef istraceback(object):\n    \"\"\"Return true if the object is a traceback.\n\n    Traceback objects provide these attributes:\n        tb_frame        frame object at this level\n        tb_lasti        index of last attempted instruction in bytecode\n        tb_lineno       current line number in Python source code\n        tb_next         next inner traceback object (called by this level)\"\"\"\n    return isinstance(object, types.TracebackType)\n\ndef isframe(object):\n    \"\"\"Return true if the object is a frame object.\n\n    Frame objects provide these attributes:\n        f_back          next outer frame object (this frame's caller)\n        f_builtins      built-in namespace seen by this frame\n        f_code          code object being executed in this frame\n        f_globals       global namespace seen by this frame\n        f_lasti         index of last attempted instruction in bytecode\n        f_lineno        current line number in Python source code\n        f_locals        local namespace seen by this frame\n        f_trace         tracing function for this frame, or None\"\"\"\n    return isinstance(object, types.FrameType)\n\ndef iscode(object):\n    \"\"\"Return true if the object is a code object.\n\n    Code objects provide these attributes:\n        co_argcount         number of arguments (not including *, ** args\n                            or keyword only arguments)\n        co_code             string of raw compiled bytecode\n        co_cellvars         tuple of names of cell variables\n        co_consts           tuple of constants used in the bytecode\n        co_filename         name of file in which this code object was created\n        co_firstlineno      number of first line in Python source code\n        co_flags            bitmap: 1=optimized | 2=newlocals | 4=*arg | 8=**arg\n                            | 16=nested | 32=generator | 64=nofree | 128=coroutine\n                            | 256=iterable_coroutine | 512=async_generator\n        co_freevars         tuple of names of free variables\n        co_posonlyargcount  number of positional only arguments\n        co_kwonlyargcount   number of keyword only arguments (not including ** arg)\n        co_lnotab           encoded mapping of line numbers to bytecode indices\n        co_name             name with which this code object was defined\n        co_names            tuple of names of local variables\n        co_nlocals          number of local variables\n        co_stacksize        virtual machine stack space required\n        co_varnames         tuple of names of arguments and local variables\"\"\"\n    return isinstance(object, types.CodeType)\n\ndef isbuiltin(object):\n    \"\"\"Return true if the object is a built-in function or method.\n\n    Built-in functions and methods provide these attributes:\n        __doc__         documentation string\n        __name__        original name of this function or method\n        __self__        instance to which a method is bound, or None\"\"\"\n    return isinstance(object, types.BuiltinFunctionType)\n\ndef isroutine(object):\n    \"\"\"Return true if the object is any kind of function or method.\"\"\"\n    return (isbuiltin(object)\n            or isfunction(object)\n            or ismethod(object)\n            or ismethoddescriptor(object))\n\ndef isabstract(object):\n    \"\"\"Return true if the object is an abstract base class (ABC).\"\"\"\n    if not isinstance(object, type):\n        return False\n    if object.__flags__ & TPFLAGS_IS_ABSTRACT:\n        return True\n    if not issubclass(type(object), abc.ABCMeta):\n        return False\n    if hasattr(object, '__abstractmethods__'):\n        # It looks like ABCMeta.__new__ has finished running;\n        # TPFLAGS_IS_ABSTRACT should have been accurate.\n        return False\n    # It looks like ABCMeta.__new__ has not finished running yet; we're\n    # probably in __init_subclass__. We'll look for abstractmethods manually.\n    for name, value in object.__dict__.items():\n        if getattr(value, \"__isabstractmethod__\", False):\n            return True\n    for base in object.__bases__:\n        for name in getattr(base, \"__abstractmethods__\", ()):\n            value = getattr(object, name, None)\n            if getattr(value, \"__isabstractmethod__\", False):\n                return True\n    return False\n\ndef getmembers(object, predicate=None):\n    \"\"\"Return all members of an object as (name, value) pairs sorted by name.\n    Optionally, only return members that satisfy a given predicate.\"\"\"\n    if isclass(object):\n        mro = (object,) + getmro(object)\n    else:\n        mro = ()\n    results = []\n    processed = set()\n    names = dir(object)\n    # :dd any DynamicClassAttributes to the list of names if object is a class;\n    # this may result in duplicate entries if, for example, a virtual\n    # attribute with the same name as a DynamicClassAttribute exists\n    try:\n        for base in object.__bases__:\n            for k, v in base.__dict__.items():\n                if isinstance(v, types.DynamicClassAttribute):\n                    names.append(k)\n    except AttributeError:\n        pass\n    for key in names:\n        # First try to get the value via getattr.  Some descriptors don't\n        # like calling their __get__ (see bug #1785), so fall back to\n        # looking in the __dict__.\n        try:\n            value = getattr(object, key)\n            # handle the duplicate key\n            if key in processed:\n                raise AttributeError\n        except AttributeError:\n            for base in mro:\n                if key in base.__dict__:\n                    value = base.__dict__[key]\n                    break\n            else:\n                # could be a (currently) missing slot member, or a buggy\n                # __dir__; discard and move on\n                continue\n        if not predicate or predicate(value):\n            results.append((key, value))\n        processed.add(key)\n    results.sort(key=lambda pair: pair[0])\n    return results\n\nAttribute = namedtuple('Attribute', 'name kind defining_class object')\n\ndef classify_class_attrs(cls):\n    \"\"\"Return list of attribute-descriptor tuples.\n\n    For each name in dir(cls), the return list contains a 4-tuple\n    with these elements:\n\n        0. The name (a string).\n\n        1. The kind of attribute this is, one of these strings:\n               'class method'    created via classmethod()\n               'static method'   created via staticmethod()\n               'property'        created via property()\n               'method'          any other flavor of method or descriptor\n               'data'            not a method\n\n        2. The class which defined this attribute (a class).\n\n        3. The object as obtained by calling getattr; if this fails, or if the\n           resulting object does not live anywhere in the class' mro (including\n           metaclasses) then the object is looked up in the defining class's\n           dict (found by walking the mro).\n\n    If one of the items in dir(cls) is stored in the metaclass it will now\n    be discovered and not have None be listed as the class in which it was\n    defined.  Any items whose home class cannot be discovered are skipped.\n    \"\"\"\n\n    mro = getmro(cls)\n    metamro = getmro(type(cls)) # for attributes stored in the metaclass\n    metamro = tuple(cls for cls in metamro if cls not in (type, object))\n    class_bases = (cls,) + mro\n    all_bases = class_bases + metamro\n    names = dir(cls)\n    # :dd any DynamicClassAttributes to the list of names;\n    # this may result in duplicate entries if, for example, a virtual\n    # attribute with the same name as a DynamicClassAttribute exists.\n    for base in mro:\n        for k, v in base.__dict__.items():\n            if isinstance(v, types.DynamicClassAttribute):\n                names.append(k)\n    result = []\n    processed = set()\n\n    for name in names:\n        # Get the object associated with the name, and where it was defined.\n        # Normal objects will be looked up with both getattr and directly in\n        # its class' dict (in case getattr fails [bug #1785], and also to look\n        # for a docstring).\n        # For DynamicClassAttributes on the second pass we only look in the\n        # class's dict.\n        #\n        # Getting an obj from the __dict__ sometimes reveals more than\n        # using getattr.  Static and class methods are dramatic examples.\n        homecls = None\n        get_obj = None\n        dict_obj = None\n        if name not in processed:\n            try:\n                if name == '__dict__':\n                    raise Exception(\"__dict__ is special, don't want the proxy\")\n                get_obj = getattr(cls, name)\n            except Exception as exc:\n                pass\n            else:\n                homecls = getattr(get_obj, \"__objclass__\", homecls)\n                if homecls not in class_bases:\n                    # if the resulting object does not live somewhere in the\n                    # mro, drop it and search the mro manually\n                    homecls = None\n                    last_cls = None\n                    # first look in the classes\n                    for srch_cls in class_bases:\n                        srch_obj = getattr(srch_cls, name, None)\n                        if srch_obj is get_obj:\n                            last_cls = srch_cls\n                    # then check the metaclasses\n                    for srch_cls in metamro:\n                        try:\n                            srch_obj = srch_cls.__getattr__(cls, name)\n                        except AttributeError:\n                            continue\n                        if srch_obj is get_obj:\n                            last_cls = srch_cls\n                    if last_cls is not None:\n                        homecls = last_cls\n        for base in all_bases:\n            if name in base.__dict__:\n                dict_obj = base.__dict__[name]\n                if homecls not in metamro:\n                    homecls = base\n                break\n        if homecls is None:\n            # unable to locate the attribute anywhere, most likely due to\n            # buggy custom __dir__; discard and move on\n            continue\n        obj = get_obj if get_obj is not None else dict_obj\n        # Classify the object or its descriptor.\n        if isinstance(dict_obj, (staticmethod, types.BuiltinMethodType)):\n            kind = \"static method\"\n            obj = dict_obj\n        elif isinstance(dict_obj, (classmethod, types.ClassMethodDescriptorType)):\n            kind = \"class method\"\n            obj = dict_obj\n        elif isinstance(dict_obj, property):\n            kind = \"property\"\n            obj = dict_obj\n        elif isroutine(obj):\n            kind = \"method\"\n        else:\n            kind = \"data\"\n        result.append(Attribute(name, kind, homecls, obj))\n        processed.add(name)\n    return result\n\n# ----------------------------------------------------------- class helpers\n\ndef getmro(cls):\n    \"Return tuple of base classes (including cls) in method resolution order.\"\n    return cls.__mro__\n\n# -------------------------------------------------------- function helpers\n\ndef unwrap(func, *, stop=None):\n    \"\"\"Get the object wrapped by *func*.\n\n   Follows the chain of :attr:`__wrapped__` attributes returning the last\n   object in the chain.\n\n   *stop* is an optional callback accepting an object in the wrapper chain\n   as its sole argument that allows the unwrapping to be terminated early if\n   the callback returns a true value. If the callback never returns a true\n   value, the last object in the chain is returned as usual. For example,\n   :func:`signature` uses this to stop unwrapping if any object in the\n   chain has a ``__signature__`` attribute defined.\n\n   :exc:`ValueError` is raised if a cycle is encountered.\n\n    \"\"\"\n    if stop is None:\n        def _is_wrapper(f):\n            return hasattr(f, '__wrapped__')\n    else:\n        def _is_wrapper(f):\n            return hasattr(f, '__wrapped__') and not stop(f)\n    f = func  # remember the original func for error reporting\n    # Memoise by id to tolerate non-hashable objects, but store objects to\n    # ensure they aren't destroyed, which would allow their IDs to be reused.\n    memo = {id(f): f}\n    recursion_limit = sys.getrecursionlimit()\n    while _is_wrapper(func):\n        func = func.__wrapped__\n        id_func = id(func)\n        if (id_func in memo) or (len(memo) >= recursion_limit):\n            raise ValueError('wrapper loop when unwrapping {!r}'.format(f))\n        memo[id_func] = func\n    return func\n\n# -------------------------------------------------- source code extraction\ndef indentsize(line):\n    \"\"\"Return the indent size, in spaces, at the start of a line of text.\"\"\"\n    expline = line.expandtabs()\n    return len(expline) - len(expline.lstrip())\n\ndef _findclass(func):\n    cls = sys.modules.get(func.__module__)\n    if cls is None:\n        return None\n    for name in func.__qualname__.split('.')[:-1]:\n        cls = getattr(cls, name)\n    if not isclass(cls):\n        return None\n    return cls\n\ndef _finddoc(obj):\n    if isclass(obj):\n        for base in obj.__mro__:\n            if base is not object:\n                try:\n                    doc = base.__doc__\n                except AttributeError:\n                    continue\n                if doc is not None:\n                    return doc\n        return None\n\n    if ismethod(obj):\n        name = obj.__func__.__name__\n        self = obj.__self__\n        if (isclass(self) and\n            getattr(getattr(self, name, None), '__func__') is obj.__func__):\n            # classmethod\n            cls = self\n        else:\n            cls = self.__class__\n    elif isfunction(obj):\n        name = obj.__name__\n        cls = _findclass(obj)\n        if cls is None or getattr(cls, name) is not obj:\n            return None\n    elif isbuiltin(obj):\n        name = obj.__name__\n        self = obj.__self__\n        if (isclass(self) and\n            self.__qualname__ + '.' + name == obj.__qualname__):\n            # classmethod\n            cls = self\n        else:\n            cls = self.__class__\n    # Should be tested before isdatadescriptor().\n    elif isinstance(obj, property):\n        func = obj.fget\n        name = func.__name__\n        cls = _findclass(func)\n        if cls is None or getattr(cls, name) is not obj:\n            return None\n    elif ismethoddescriptor(obj) or isdatadescriptor(obj):\n        name = obj.__name__\n        cls = obj.__objclass__\n        if getattr(cls, name) is not obj:\n            return None\n        if ismemberdescriptor(obj):\n            slots = getattr(cls, '__slots__', None)\n            if isinstance(slots, dict) and name in slots:\n                return slots[name]\n    else:\n        return None\n    for base in cls.__mro__:\n        try:\n            doc = getattr(base, name).__doc__\n        except AttributeError:\n            continue\n        if doc is not None:\n            return doc\n    return None\n\ndef getdoc(object):\n    \"\"\"Get the documentation string for an object.\n\n    All tabs are expanded to spaces.  To clean up docstrings that are\n    indented to line up with blocks of code, any whitespace than can be\n    uniformly removed from the second line onwards is removed.\"\"\"\n    try:\n        doc = object.__doc__\n    except AttributeError:\n        return None\n    if doc is None:\n        try:\n            doc = _finddoc(object)\n        except (AttributeError, TypeError):\n            return None\n    if not isinstance(doc, str):\n        return None\n    return cleandoc(doc)\n\ndef cleandoc(doc):\n    \"\"\"Clean up indentation from docstrings.\n\n    Any whitespace that can be uniformly removed from the second line\n    onwards is removed.\"\"\"\n    try:\n        lines = doc.expandtabs().split('\\n')\n    except UnicodeError:\n        return None\n    else:\n        # Find minimum indentation of any non-blank lines after first line.\n        margin = sys.maxsize\n        for line in lines[1:]:\n            content = len(line.lstrip())\n            if content:\n                indent = len(line) - content\n                margin = min(margin, indent)\n        # Remove indentation.\n        if lines:\n            lines[0] = lines[0].lstrip()\n        if margin < sys.maxsize:\n            for i in range(1, len(lines)): lines[i] = lines[i][margin:]\n        # Remove any trailing or leading blank lines.\n        while lines and not lines[-1]:\n            lines.pop()\n        while lines and not lines[0]:\n            lines.pop(0)\n        return '\\n'.join(lines)\n\ndef getfile(object):\n    \"\"\"Work out which source or compiled file an object was defined in.\"\"\"\n    if ismodule(object):\n        if getattr(object, '__file__', None):\n            return object.__file__\n        raise TypeError('{!r} is a built-in module'.format(object))\n    if isclass(object):\n        if hasattr(object, '__module__'):\n            module = sys.modules.get(object.__module__)\n            if getattr(module, '__file__', None):\n                return module.__file__\n        raise TypeError('{!r} is a built-in class'.format(object))\n    if ismethod(object):\n        object = object.__func__\n    if isfunction(object):\n        object = object.__code__\n    if istraceback(object):\n        object = object.tb_frame\n    if isframe(object):\n        object = object.f_code\n    if iscode(object):\n        return object.co_filename\n    raise TypeError('module, class, method, function, traceback, frame, or '\n                    'code object was expected, got {}'.format(\n                    type(object).__name__))\n\ndef getmodulename(path):\n    \"\"\"Return the module name for a given file, or None.\"\"\"\n    fname = os.path.basename(path)\n    # Check for paths that look like an actual module file\n    suffixes = [(-len(suffix), suffix)\n                    for suffix in importlib.machinery.all_suffixes()]\n    suffixes.sort() # try longest suffixes first, in case they overlap\n    for neglen, suffix in suffixes:\n        if fname.endswith(suffix):\n            return fname[:neglen]\n    return None\n\ndef getsourcefile(object):\n    \"\"\"Return the filename that can be used to locate an object's source.\n    Return None if no way can be identified to get the source.\n    \"\"\"\n    filename = getfile(object)\n    all_bytecode_suffixes = importlib.machinery.DEBUG_BYTECODE_SUFFIXES[:]\n    all_bytecode_suffixes += importlib.machinery.OPTIMIZED_BYTECODE_SUFFIXES[:]\n    if any(filename.endswith(s) for s in all_bytecode_suffixes):\n        filename = (os.path.splitext(filename)[0] +\n                    importlib.machinery.SOURCE_SUFFIXES[0])\n    elif any(filename.endswith(s) for s in\n                 importlib.machinery.EXTENSION_SUFFIXES):\n        return None\n    if os.path.exists(filename):\n        return filename\n    # only return a non-existent filename if the module has a PEP 302 loader\n    if getattr(getmodule(object, filename), '__loader__', None) is not None:\n        return filename\n    # or it is in the linecache\n    if filename in linecache.cache:\n        return filename\n\ndef getabsfile(object, _filename=None):\n    \"\"\"Return an absolute path to the source or compiled file for an object.\n\n    The idea is for each object to have a unique origin, so this routine\n    normalizes the result as much as possible.\"\"\"\n    if _filename is None:\n        _filename = getsourcefile(object) or getfile(object)\n    return os.path.normcase(os.path.abspath(_filename))\n\nmodulesbyfile = {}\n_filesbymodname = {}\n\ndef getmodule(object, _filename=None):\n    \"\"\"Return the module an object was defined in, or None if not found.\"\"\"\n    if ismodule(object):\n        return object\n    if hasattr(object, '__module__'):\n        return sys.modules.get(object.__module__)\n    # Try the filename to modulename cache\n    if _filename is not None and _filename in modulesbyfile:\n        return sys.modules.get(modulesbyfile[_filename])\n    # Try the cache again with the absolute file name\n    try:\n        file = getabsfile(object, _filename)\n    except TypeError:\n        return None\n    if file in modulesbyfile:\n        return sys.modules.get(modulesbyfile[file])\n    # Update the filename to module name cache and check yet again\n    # Copy sys.modules in order to cope with changes while iterating\n    for modname, module in sys.modules.copy().items():\n        if ismodule(module) and hasattr(module, '__file__'):\n            f = module.__file__\n            if f == _filesbymodname.get(modname, None):\n                # Have already mapped this module, so skip it\n                continue\n            _filesbymodname[modname] = f\n            f = getabsfile(module)\n            # Always map to the name the module knows itself by\n            modulesbyfile[f] = modulesbyfile[\n                os.path.realpath(f)] = module.__name__\n    if file in modulesbyfile:\n        return sys.modules.get(modulesbyfile[file])\n    # Check the main module\n    main = sys.modules['__main__']\n    if not hasattr(object, '__name__'):\n        return None\n    if hasattr(main, object.__name__):\n        mainobject = getattr(main, object.__name__)\n        if mainobject is object:\n            return main\n    # Check builtins\n    builtin = sys.modules['builtins']\n    if hasattr(builtin, object.__name__):\n        builtinobject = getattr(builtin, object.__name__)\n        if builtinobject is object:\n            return builtin\n\ndef findsource(object):\n    \"\"\"Return the entire source file and starting line number for an object.\n\n    The argument may be a module, class, method, function, traceback, frame,\n    or code object.  The source code is returned as a list of all the lines\n    in the file and the line number indexes a line in that list.  An OSError\n    is raised if the source code cannot be retrieved.\"\"\"\n\n    file = getsourcefile(object)\n    if file:\n        # Invalidate cache if needed.\n        linecache.checkcache(file)\n    else:\n        file = getfile(object)\n        # Allow filenames in form of \"<something>\" to pass through.\n        # `doctest` monkeypatches `linecache` module to enable\n        # inspection, so let `linecache.getlines` to be called.\n        if not (file.startswith('<') and file.endswith('>')):\n            raise OSError('source code not available')\n\n    module = getmodule(object, file)\n    if module:\n        lines = linecache.getlines(file, module.__dict__)\n    else:\n        lines = linecache.getlines(file)\n    if not lines:\n        raise OSError('could not get source code')\n\n    if ismodule(object):\n        return lines, 0\n\n    if isclass(object):\n        name = object.__name__\n        pat = re.compile(r'^(\\s*)class\\s*' + name + r'\\b')\n        # make some effort to find the best matching class definition:\n        # use the one with the least indentation, which is the one\n        # that's most probably not inside a function definition.\n        candidates = []\n        for i in range(len(lines)):\n            match = pat.match(lines[i])\n            if match:\n                # if it's at toplevel, it's already the best one\n                if lines[i][0] == 'c':\n                    return lines, i\n                # else add whitespace to candidate list\n                candidates.append((match.group(1), i))\n        if candidates:\n            # this will sort by whitespace, and by line number,\n            # less whitespace first\n            candidates.sort()\n            return lines, candidates[0][1]\n        else:\n            raise OSError('could not find class definition')\n\n    if ismethod(object):\n        object = object.__func__\n    if isfunction(object):\n        object = object.__code__\n    if istraceback(object):\n        object = object.tb_frame\n    if isframe(object):\n        object = object.f_code\n    if iscode(object):\n        if not hasattr(object, 'co_firstlineno'):\n            raise OSError('could not find function definition')\n        lnum = object.co_firstlineno - 1\n        pat = re.compile(r'^(\\s*def\\s)|(\\s*async\\s+def\\s)|(.*(?<!\\w)lambda(:|\\s))|^(\\s*@)')\n        while lnum > 0:\n            try:\n                line = lines[lnum]\n            except IndexError:\n                raise OSError('lineno is out of bounds')\n            if pat.match(line):\n                break\n            lnum = lnum - 1\n        return lines, lnum\n    raise OSError('could not find code object')\n\ndef getcomments(object):\n    \"\"\"Get lines of comments immediately preceding an object's source code.\n\n    Returns None when source can't be found.\n    \"\"\"\n    try:\n        lines, lnum = findsource(object)\n    except (OSError, TypeError):\n        return None\n\n    if ismodule(object):\n        # Look for a comment block at the top of the file.\n        start = 0\n        if lines and lines[0][:2] == '#!': start = 1\n        while start < len(lines) and lines[start].strip() in ('', '#'):\n            start = start + 1\n        if start < len(lines) and lines[start][:1] == '#':\n            comments = []\n            end = start\n            while end < len(lines) and lines[end][:1] == '#':\n                comments.append(lines[end].expandtabs())\n                end = end + 1\n            return ''.join(comments)\n\n    # Look for a preceding block of comments at the same indentation.\n    elif lnum > 0:\n        indent = indentsize(lines[lnum])\n        end = lnum - 1\n        if end >= 0 and lines[end].lstrip()[:1] == '#' and \\\n            indentsize(lines[end]) == indent:\n            comments = [lines[end].expandtabs().lstrip()]\n            if end > 0:\n                end = end - 1\n                comment = lines[end].expandtabs().lstrip()\n                while comment[:1] == '#' and indentsize(lines[end]) == indent:\n                    comments[:0] = [comment]\n                    end = end - 1\n                    if end < 0: break\n                    comment = lines[end].expandtabs().lstrip()\n            while comments and comments[0].strip() == '#':\n                comments[:1] = []\n            while comments and comments[-1].strip() == '#':\n                comments[-1:] = []\n            return ''.join(comments)\n\nclass EndOfBlock(Exception): pass\n\nclass BlockFinder:\n    \"\"\"Provide a tokeneater() method to detect the end of a code block.\"\"\"\n    def __init__(self):\n        self.indent = 0\n        self.islambda = False\n        self.started = False\n        self.passline = False\n        self.indecorator = False\n        self.decoratorhasargs = False\n        self.last = 1\n        self.body_col0 = None\n\n    def tokeneater(self, type, token, srowcol, erowcol, line):\n        if not self.started and not self.indecorator:\n            # skip any decorators\n            if token == \"@\":\n                self.indecorator = True\n            # look for the first \"def\", \"class\" or \"lambda\"\n            elif token in (\"def\", \"class\", \"lambda\"):\n                if token == \"lambda\":\n                    self.islambda = True\n                self.started = True\n            self.passline = True    # skip to the end of the line\n        elif token == \"(\":\n            if self.indecorator:\n                self.decoratorhasargs = True\n        elif token == \")\":\n            if self.indecorator:\n                self.indecorator = False\n                self.decoratorhasargs = False\n        elif type == tokenize.NEWLINE:\n            self.passline = False   # stop skipping when a NEWLINE is seen\n            self.last = srowcol[0]\n            if self.islambda:       # lambdas always end at the first NEWLINE\n                raise EndOfBlock\n            # hitting a NEWLINE when in a decorator without args\n            # ends the decorator\n            if self.indecorator and not self.decoratorhasargs:\n                self.indecorator = False\n        elif self.passline:\n            pass\n        elif type == tokenize.INDENT:\n            if self.body_col0 is None and self.started:\n                self.body_col0 = erowcol[1]\n            self.indent = self.indent + 1\n            self.passline = True\n        elif type == tokenize.DEDENT:\n            self.indent = self.indent - 1\n            # the end of matching indent/dedent pairs end a block\n            # (note that this only works for \"def\"/\"class\" blocks,\n            #  not e.g. for \"if: else:\" or \"try: finally:\" blocks)\n            if self.indent <= 0:\n                raise EndOfBlock\n        elif type == tokenize.COMMENT:\n            if self.body_col0 is not None and srowcol[1] >= self.body_col0:\n                # Include comments if indented at least as much as the block\n                self.last = srowcol[0]\n        elif self.indent == 0 and type not in (tokenize.COMMENT, tokenize.NL):\n            # any other token on the same indentation level end the previous\n            # block as well, except the pseudo-tokens COMMENT and NL.\n            raise EndOfBlock\n\ndef getblock(lines):\n    \"\"\"Extract the block of code at the top of the given list of lines.\"\"\"\n    blockfinder = BlockFinder()\n    try:\n        tokens = tokenize.generate_tokens(iter(lines).__next__)\n        for _token in tokens:\n            blockfinder.tokeneater(*_token)\n    except (EndOfBlock, IndentationError):\n        pass\n    return lines[:blockfinder.last]\n\ndef getsourcelines(object):\n    \"\"\"Return a list of source lines and starting line number for an object.\n\n    The argument may be a module, class, method, function, traceback, frame,\n    or code object.  The source code is returned as a list of the lines\n    corresponding to the object and the line number indicates where in the\n    original source file the first line of code was found.  An OSError is\n    raised if the source code cannot be retrieved.\"\"\"\n    object = unwrap(object)\n    lines, lnum = findsource(object)\n\n    if istraceback(object):\n        object = object.tb_frame\n\n    # for module or frame that corresponds to module, return all source lines\n    if (ismodule(object) or\n        (isframe(object) and object.f_code.co_name == \"<module>\")):\n        return lines, 0\n    else:\n        return getblock(lines[lnum:]), lnum + 1\n\ndef getsource(object):\n    \"\"\"Return the text of the source code for an object.\n\n    The argument may be a module, class, method, function, traceback, frame,\n    or code object.  The source code is returned as a single string.  An\n    OSError is raised if the source code cannot be retrieved.\"\"\"\n    lines, lnum = getsourcelines(object)\n    return ''.join(lines)\n\n# --------------------------------------------------- class tree extraction\ndef walktree(classes, children, parent):\n    \"\"\"Recursive helper function for getclasstree().\"\"\"\n    results = []\n    classes.sort(key=attrgetter('__module__', '__name__'))\n    for c in classes:\n        results.append((c, c.__bases__))\n        if c in children:\n            results.append(walktree(children[c], children, c))\n    return results\n\ndef getclasstree(classes, unique=False):\n    \"\"\"Arrange the given list of classes into a hierarchy of nested lists.\n\n    Where a nested list appears, it contains classes derived from the class\n    whose entry immediately precedes the list.  Each entry is a 2-tuple\n    containing a class and a tuple of its base classes.  If the 'unique'\n    argument is true, exactly one entry appears in the returned structure\n    for each class in the given list.  Otherwise, classes using multiple\n    inheritance and their descendants will appear multiple times.\"\"\"\n    children = {}\n    roots = []\n    for c in classes:\n        if c.__bases__:\n            for parent in c.__bases__:\n                if parent not in children:\n                    children[parent] = []\n                if c not in children[parent]:\n                    children[parent].append(c)\n                if unique and parent in classes: break\n        elif c not in roots:\n            roots.append(c)\n    for parent in children:\n        if parent not in classes:\n            roots.append(parent)\n    return walktree(roots, children, None)\n\n# ------------------------------------------------ argument list extraction\nArguments = namedtuple('Arguments', 'args, varargs, varkw')\n\ndef getargs(co):\n    \"\"\"Get information about the arguments accepted by a code object.\n\n    Three things are returned: (args, varargs, varkw), where\n    'args' is the list of argument names. Keyword-only arguments are\n    appended. 'varargs' and 'varkw' are the names of the * and **\n    arguments or None.\"\"\"\n    if not iscode(co):\n        raise TypeError('{!r} is not a code object'.format(co))\n\n    names = co.co_varnames\n    nargs = co.co_argcount\n    nkwargs = co.co_kwonlyargcount\n    args = list(names[:nargs])\n    kwonlyargs = list(names[nargs:nargs+nkwargs])\n    step = 0\n\n    nargs += nkwargs\n    varargs = None\n    if co.co_flags & CO_VARARGS:\n        varargs = co.co_varnames[nargs]\n        nargs = nargs + 1\n    varkw = None\n    if co.co_flags & CO_VARKEYWORDS:\n        varkw = co.co_varnames[nargs]\n    return Arguments(args + kwonlyargs, varargs, varkw)\n\nArgSpec = namedtuple('ArgSpec', 'args varargs keywords defaults')\n\ndef getargspec(func):\n    \"\"\"Get the names and default values of a function's parameters.\n\n    A tuple of four things is returned: (args, varargs, keywords, defaults).\n    'args' is a list of the argument names, including keyword-only argument names.\n    'varargs' and 'keywords' are the names of the * and ** parameters or None.\n    'defaults' is an n-tuple of the default values of the last n parameters.\n\n    This function is deprecated, as it does not support annotations or\n    keyword-only parameters and will raise ValueError if either is present\n    on the supplied callable.\n\n    For a more structured introspection API, use inspect.signature() instead.\n\n    Alternatively, use getfullargspec() for an API with a similar namedtuple\n    based interface, but full support for annotations and keyword-only\n    parameters.\n\n    Deprecated since Python 3.5, use `inspect.getfullargspec()`.\n    \"\"\"\n    warnings.warn(\"inspect.getargspec() is deprecated since Python 3.0, \"\n                  \"use inspect.signature() or inspect.getfullargspec()\",\n                  DeprecationWarning, stacklevel=2)\n    args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, ann = \\\n        getfullargspec(func)\n    if kwonlyargs or ann:\n        raise ValueError(\"Function has keyword-only parameters or annotations\"\n                         \", use inspect.signature() API which can support them\")\n    return ArgSpec(args, varargs, varkw, defaults)\n\nFullArgSpec = namedtuple('FullArgSpec',\n    'args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, annotations')\n\ndef getfullargspec(func):\n    \"\"\"Get the names and default values of a callable object's parameters.\n\n    A tuple of seven things is returned:\n    (args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, annotations).\n    'args' is a list of the parameter names.\n    'varargs' and 'varkw' are the names of the * and ** parameters or None.\n    'defaults' is an n-tuple of the default values of the last n parameters.\n    'kwonlyargs' is a list of keyword-only parameter names.\n    'kwonlydefaults' is a dictionary mapping names from kwonlyargs to defaults.\n    'annotations' is a dictionary mapping parameter names to annotations.\n\n    Notable differences from inspect.signature():\n      - the \"self\" parameter is always reported, even for bound methods\n      - wrapper chains defined by __wrapped__ *not* unwrapped automatically\n    \"\"\"\n    try:\n        # Re: `skip_bound_arg=False`\n        #\n        # There is a notable difference in behaviour between getfullargspec\n        # and Signature: the former always returns 'self' parameter for bound\n        # methods, whereas the Signature always shows the actual calling\n        # signature of the passed object.\n        #\n        # To simulate this behaviour, we \"unbind\" bound methods, to trick\n        # inspect.signature to always return their first parameter (\"self\",\n        # usually)\n\n        # Re: `follow_wrapper_chains=False`\n        #\n        # getfullargspec() historically ignored __wrapped__ attributes,\n        # so we ensure that remains the case in 3.3+\n\n        sig = _signature_from_callable(func,\n                                       follow_wrapper_chains=False,\n                                       skip_bound_arg=False,\n                                       sigcls=Signature)\n    except Exception as ex:\n        # Most of the times 'signature' will raise ValueError.\n        # But, it can also raise AttributeError, and, maybe something\n        # else. So to be fully backwards compatible, we catch all\n        # possible exceptions here, and reraise a TypeError.\n        raise TypeError('unsupported callable') from ex\n\n    args = []\n    varargs = None\n    varkw = None\n    posonlyargs = []\n    kwonlyargs = []\n    defaults = ()\n    annotations = {}\n    defaults = ()\n    kwdefaults = {}\n\n    if sig.return_annotation is not sig.empty:\n        annotations['return'] = sig.return_annotation\n\n    for param in sig.parameters.values():\n        kind = param.kind\n        name = param.name\n\n        if kind is _POSITIONAL_ONLY:\n            posonlyargs.append(name)\n            if param.default is not param.empty:\n                defaults += (param.default,)\n        elif kind is _POSITIONAL_OR_KEYWORD:\n            args.append(name)\n            if param.default is not param.empty:\n                defaults += (param.default,)\n        elif kind is _VAR_POSITIONAL:\n            varargs = name\n        elif kind is _KEYWORD_ONLY:\n            kwonlyargs.append(name)\n            if param.default is not param.empty:\n                kwdefaults[name] = param.default\n        elif kind is _VAR_KEYWORD:\n            varkw = name\n\n        if param.annotation is not param.empty:\n            annotations[name] = param.annotation\n\n    if not kwdefaults:\n        # compatibility with 'func.__kwdefaults__'\n        kwdefaults = None\n\n    if not defaults:\n        # compatibility with 'func.__defaults__'\n        defaults = None\n\n    return FullArgSpec(posonlyargs + args, varargs, varkw, defaults,\n                       kwonlyargs, kwdefaults, annotations)\n\n\nArgInfo = namedtuple('ArgInfo', 'args varargs keywords locals')\n\ndef getargvalues(frame):\n    \"\"\"Get information about arguments passed into a particular frame.\n\n    A tuple of four things is returned: (args, varargs, varkw, locals).\n    'args' is a list of the argument names.\n    'varargs' and 'varkw' are the names of the * and ** arguments or None.\n    'locals' is the locals dictionary of the given frame.\"\"\"\n    args, varargs, varkw = getargs(frame.f_code)\n    return ArgInfo(args, varargs, varkw, frame.f_locals)\n\ndef formatannotation(annotation, base_module=None):\n    if getattr(annotation, '__module__', None) == 'typing':\n        return repr(annotation).replace('typing.', '')\n    if isinstance(annotation, type):\n        if annotation.__module__ in ('builtins', base_module):\n            return annotation.__qualname__\n        return annotation.__module__+'.'+annotation.__qualname__\n    return repr(annotation)\n\ndef formatannotationrelativeto(object):\n    module = getattr(object, '__module__', None)\n    def _formatannotation(annotation):\n        return formatannotation(annotation, module)\n    return _formatannotation\n\ndef formatargspec(args, varargs=None, varkw=None, defaults=None,\n                  kwonlyargs=(), kwonlydefaults={}, annotations={},\n                  formatarg=str,\n                  formatvarargs=lambda name: '*' + name,\n                  formatvarkw=lambda name: '**' + name,\n                  formatvalue=lambda value: '=' + repr(value),\n                  formatreturns=lambda text: ' -> ' + text,\n                  formatannotation=formatannotation):\n    \"\"\"Format an argument spec from the values returned by getfullargspec.\n\n    The first seven arguments are (args, varargs, varkw, defaults,\n    kwonlyargs, kwonlydefaults, annotations).  The other five arguments\n    are the corresponding optional formatting functions that are called to\n    turn names and values into strings.  The last argument is an optional\n    function to format the sequence of arguments.\n\n    Deprecated since Python 3.5: use the `signature` function and `Signature`\n    objects.\n    \"\"\"\n\n    from warnings import warn\n\n    warn(\"`formatargspec` is deprecated since Python 3.5. Use `signature` and \"\n         \"the `Signature` object directly\",\n         DeprecationWarning,\n         stacklevel=2)\n\n    def formatargandannotation(arg):\n        result = formatarg(arg)\n        if arg in annotations:\n            result += ': ' + formatannotation(annotations[arg])\n        return result\n    specs = []\n    if defaults:\n        firstdefault = len(args) - len(defaults)\n    for i, arg in enumerate(args):\n        spec = formatargandannotation(arg)\n        if defaults and i >= firstdefault:\n            spec = spec + formatvalue(defaults[i - firstdefault])\n        specs.append(spec)\n    if varargs is not None:\n        specs.append(formatvarargs(formatargandannotation(varargs)))\n    else:\n        if kwonlyargs:\n            specs.append('*')\n    if kwonlyargs:\n        for kwonlyarg in kwonlyargs:\n            spec = formatargandannotation(kwonlyarg)\n            if kwonlydefaults and kwonlyarg in kwonlydefaults:\n                spec += formatvalue(kwonlydefaults[kwonlyarg])\n            specs.append(spec)\n    if varkw is not None:\n        specs.append(formatvarkw(formatargandannotation(varkw)))\n    result = '(' + ', '.join(specs) + ')'\n    if 'return' in annotations:\n        result += formatreturns(formatannotation(annotations['return']))\n    return result\n\ndef formatargvalues(args, varargs, varkw, locals,\n                    formatarg=str,\n                    formatvarargs=lambda name: '*' + name,\n                    formatvarkw=lambda name: '**' + name,\n                    formatvalue=lambda value: '=' + repr(value)):\n    \"\"\"Format an argument spec from the 4 values returned by getargvalues.\n\n    The first four arguments are (args, varargs, varkw, locals).  The\n    next four arguments are the corresponding optional formatting functions\n    that are called to turn names and values into strings.  The ninth\n    argument is an optional function to format the sequence of arguments.\"\"\"\n    def convert(name, locals=locals,\n                formatarg=formatarg, formatvalue=formatvalue):\n        return formatarg(name) + formatvalue(locals[name])\n    specs = []\n    for i in range(len(args)):\n        specs.append(convert(args[i]))\n    if varargs:\n        specs.append(formatvarargs(varargs) + formatvalue(locals[varargs]))\n    if varkw:\n        specs.append(formatvarkw(varkw) + formatvalue(locals[varkw]))\n    return '(' + ', '.join(specs) + ')'\n\ndef _missing_arguments(f_name, argnames, pos, values):\n    names = [repr(name) for name in argnames if name not in values]\n    missing = len(names)\n    if missing == 1:\n        s = names[0]\n    elif missing == 2:\n        s = \"{} and {}\".format(*names)\n    else:\n        tail = \", {} and {}\".format(*names[-2:])\n        del names[-2:]\n        s = \", \".join(names) + tail\n    raise TypeError(\"%s() missing %i required %s argument%s: %s\" %\n                    (f_name, missing,\n                      \"positional\" if pos else \"keyword-only\",\n                      \"\" if missing == 1 else \"s\", s))\n\ndef _too_many(f_name, args, kwonly, varargs, defcount, given, values):\n    atleast = len(args) - defcount\n    kwonly_given = len([arg for arg in kwonly if arg in values])\n    if varargs:\n        plural = atleast != 1\n        sig = \"at least %d\" % (atleast,)\n    elif defcount:\n        plural = True\n        sig = \"from %d to %d\" % (atleast, len(args))\n    else:\n        plural = len(args) != 1\n        sig = str(len(args))\n    kwonly_sig = \"\"\n    if kwonly_given:\n        msg = \" positional argument%s (and %d keyword-only argument%s)\"\n        kwonly_sig = (msg % (\"s\" if given != 1 else \"\", kwonly_given,\n                             \"s\" if kwonly_given != 1 else \"\"))\n    raise TypeError(\"%s() takes %s positional argument%s but %d%s %s given\" %\n            (f_name, sig, \"s\" if plural else \"\", given, kwonly_sig,\n             \"was\" if given == 1 and not kwonly_given else \"were\"))\n\ndef getcallargs(func, /, *positional, **named):\n    \"\"\"Get the mapping of arguments to values.\n\n    A dict is returned, with keys the function argument names (including the\n    names of the * and ** arguments, if any), and values the respective bound\n    values from 'positional' and 'named'.\"\"\"\n    spec = getfullargspec(func)\n    args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, ann = spec\n    f_name = func.__name__\n    arg2value = {}\n\n\n    if ismethod(func) and func.__self__ is not None:\n        # implicit 'self' (or 'cls' for classmethods) argument\n        positional = (func.__self__,) + positional\n    num_pos = len(positional)\n    num_args = len(args)\n    num_defaults = len(defaults) if defaults else 0\n\n    n = min(num_pos, num_args)\n    for i in range(n):\n        arg2value[args[i]] = positional[i]\n    if varargs:\n        arg2value[varargs] = tuple(positional[n:])\n    possible_kwargs = set(args + kwonlyargs)\n    if varkw:\n        arg2value[varkw] = {}\n    for kw, value in named.items():\n        if kw not in possible_kwargs:\n            if not varkw:\n                raise TypeError(\"%s() got an unexpected keyword argument %r\" %\n                                (f_name, kw))\n            arg2value[varkw][kw] = value\n            continue\n        if kw in arg2value:\n            raise TypeError(\"%s() got multiple values for argument %r\" %\n                            (f_name, kw))\n        arg2value[kw] = value\n    if num_pos > num_args and not varargs:\n        _too_many(f_name, args, kwonlyargs, varargs, num_defaults,\n                   num_pos, arg2value)\n    if num_pos < num_args:\n        req = args[:num_args - num_defaults]\n        for arg in req:\n            if arg not in arg2value:\n                _missing_arguments(f_name, req, True, arg2value)\n        for i, arg in enumerate(args[num_args - num_defaults:]):\n            if arg not in arg2value:\n                arg2value[arg] = defaults[i]\n    missing = 0\n    for kwarg in kwonlyargs:\n        if kwarg not in arg2value:\n            if kwonlydefaults and kwarg in kwonlydefaults:\n                arg2value[kwarg] = kwonlydefaults[kwarg]\n            else:\n                missing += 1\n    if missing:\n        _missing_arguments(f_name, kwonlyargs, False, arg2value)\n    return arg2value\n\nClosureVars = namedtuple('ClosureVars', 'nonlocals globals builtins unbound')\n\ndef getclosurevars(func):\n    \"\"\"\n    Get the mapping of free variables to their current values.\n\n    Returns a named tuple of dicts mapping the current nonlocal, global\n    and builtin references as seen by the body of the function. A final\n    set of unbound names that could not be resolved is also provided.\n    \"\"\"\n\n    if ismethod(func):\n        func = func.__func__\n\n    if not isfunction(func):\n        raise TypeError(\"{!r} is not a Python function\".format(func))\n\n    code = func.__code__\n    # Nonlocal references are named in co_freevars and resolved\n    # by looking them up in __closure__ by positional index\n    if func.__closure__ is None:\n        nonlocal_vars = {}\n    else:\n        nonlocal_vars = {\n            var : cell.cell_contents\n            for var, cell in zip(code.co_freevars, func.__closure__)\n       }\n\n    # Global and builtin references are named in co_names and resolved\n    # by looking them up in __globals__ or __builtins__\n    global_ns = func.__globals__\n    builtin_ns = global_ns.get(\"__builtins__\", builtins.__dict__)\n    if ismodule(builtin_ns):\n        builtin_ns = builtin_ns.__dict__\n    global_vars = {}\n    builtin_vars = {}\n    unbound_names = set()\n    for name in code.co_names:\n        if name in (\"None\", \"True\", \"False\"):\n            # Because these used to be builtins instead of keywords, they\n            # may still show up as name references. We ignore them.\n            continue\n        try:\n            global_vars[name] = global_ns[name]\n        except KeyError:\n            try:\n                builtin_vars[name] = builtin_ns[name]\n            except KeyError:\n                unbound_names.add(name)\n\n    return ClosureVars(nonlocal_vars, global_vars,\n                       builtin_vars, unbound_names)\n\n# -------------------------------------------------- stack frame extraction\n\nTraceback = namedtuple('Traceback', 'filename lineno function code_context index')\n\ndef getframeinfo(frame, context=1):\n    \"\"\"Get information about a frame or traceback object.\n\n    A tuple of five things is returned: the filename, the line number of\n    the current line, the function name, a list of lines of context from\n    the source code, and the index of the current line within that list.\n    The optional second argument specifies the number of lines of context\n    to return, which are centered around the current line.\"\"\"\n    if istraceback(frame):\n        lineno = frame.tb_lineno\n        frame = frame.tb_frame\n    else:\n        lineno = frame.f_lineno\n    if not isframe(frame):\n        raise TypeError('{!r} is not a frame or traceback object'.format(frame))\n\n    filename = getsourcefile(frame) or getfile(frame)\n    if context > 0:\n        start = lineno - 1 - context//2\n        try:\n            lines, lnum = findsource(frame)\n        except OSError:\n            lines = index = None\n        else:\n            start = max(0, min(start, len(lines) - context))\n            lines = lines[start:start+context]\n            index = lineno - 1 - start\n    else:\n        lines = index = None\n\n    return Traceback(filename, lineno, frame.f_code.co_name, lines, index)\n\ndef getlineno(frame):\n    \"\"\"Get the line number from a frame object, allowing for optimization.\"\"\"\n    # FrameType.f_lineno is now a descriptor that grovels co_lnotab\n    return frame.f_lineno\n\nFrameInfo = namedtuple('FrameInfo', ('frame',) + Traceback._fields)\n\ndef getouterframes(frame, context=1):\n    \"\"\"Get a list of records for a frame and all higher (calling) frames.\n\n    Each record contains a frame object, filename, line number, function\n    name, a list of lines of context, and index within the context.\"\"\"\n    framelist = []\n    while frame:\n        frameinfo = (frame,) + getframeinfo(frame, context)\n        framelist.append(FrameInfo(*frameinfo))\n        frame = frame.f_back\n    return framelist\n\ndef getinnerframes(tb, context=1):\n    \"\"\"Get a list of records for a traceback's frame and all lower frames.\n\n    Each record contains a frame object, filename, line number, function\n    name, a list of lines of context, and index within the context.\"\"\"\n    framelist = []\n    while tb:\n        frameinfo = (tb.tb_frame,) + getframeinfo(tb, context)\n        framelist.append(FrameInfo(*frameinfo))\n        tb = tb.tb_next\n    return framelist\n\ndef currentframe():\n    \"\"\"Return the frame of the caller or None if this is not possible.\"\"\"\n    return sys._getframe(1) if hasattr(sys, \"_getframe\") else None\n\ndef stack(context=1):\n    \"\"\"Return a list of records for the stack above the caller's frame.\"\"\"\n    return getouterframes(sys._getframe(1), context)\n\ndef trace(context=1):\n    \"\"\"Return a list of records for the stack below the current exception.\"\"\"\n    return getinnerframes(sys.exc_info()[2], context)\n\n\n# ------------------------------------------------ static version of getattr\n\n_sentinel = object()\n\ndef _static_getmro(klass):\n    return type.__dict__['__mro__'].__get__(klass)\n\ndef _check_instance(obj, attr):\n    instance_dict = {}\n    try:\n        instance_dict = object.__getattribute__(obj, \"__dict__\")\n    except AttributeError:\n        pass\n    return dict.get(instance_dict, attr, _sentinel)\n\n\ndef _check_class(klass, attr):\n    for entry in _static_getmro(klass):\n        if _shadowed_dict(type(entry)) is _sentinel:\n            try:\n                return entry.__dict__[attr]\n            except KeyError:\n                pass\n    return _sentinel\n\ndef _is_type(obj):\n    try:\n        _static_getmro(obj)\n    except TypeError:\n        return False\n    return True\n\ndef _shadowed_dict(klass):\n    dict_attr = type.__dict__[\"__dict__\"]\n    for entry in _static_getmro(klass):\n        try:\n            class_dict = dict_attr.__get__(entry)[\"__dict__\"]\n        except KeyError:\n            pass\n        else:\n            if not (type(class_dict) is types.GetSetDescriptorType and\n                    class_dict.__name__ == \"__dict__\" and\n                    class_dict.__objclass__ is entry):\n                return class_dict\n    return _sentinel\n\ndef getattr_static(obj, attr, default=_sentinel):\n    \"\"\"Retrieve attributes without triggering dynamic lookup via the\n       descriptor protocol,  __getattr__ or __getattribute__.\n\n       Note: this function may not be able to retrieve all attributes\n       that getattr can fetch (like dynamically created attributes)\n       and may find attributes that getattr can't (like descriptors\n       that raise AttributeError). It can also return descriptor objects\n       instead of instance members in some cases. See the\n       documentation for details.\n    \"\"\"\n    instance_result = _sentinel\n    if not _is_type(obj):\n        klass = type(obj)\n        dict_attr = _shadowed_dict(klass)\n        if (dict_attr is _sentinel or\n            type(dict_attr) is types.MemberDescriptorType):\n            instance_result = _check_instance(obj, attr)\n    else:\n        klass = obj\n\n    klass_result = _check_class(klass, attr)\n\n    if instance_result is not _sentinel and klass_result is not _sentinel:\n        if (_check_class(type(klass_result), '__get__') is not _sentinel and\n            _check_class(type(klass_result), '__set__') is not _sentinel):\n            return klass_result\n\n    if instance_result is not _sentinel:\n        return instance_result\n    if klass_result is not _sentinel:\n        return klass_result\n\n    if obj is klass:\n        # for types we check the metaclass too\n        for entry in _static_getmro(type(klass)):\n            if _shadowed_dict(type(entry)) is _sentinel:\n                try:\n                    return entry.__dict__[attr]\n                except KeyError:\n                    pass\n    if default is not _sentinel:\n        return default\n    raise AttributeError(attr)\n\n\n# ------------------------------------------------ generator introspection\n\nGEN_CREATED = 'GEN_CREATED'\nGEN_RUNNING = 'GEN_RUNNING'\nGEN_SUSPENDED = 'GEN_SUSPENDED'\nGEN_CLOSED = 'GEN_CLOSED'\n\ndef getgeneratorstate(generator):\n    \"\"\"Get current state of a generator-iterator.\n\n    Possible states are:\n      GEN_CREATED: Waiting to start execution.\n      GEN_RUNNING: Currently being executed by the interpreter.\n      GEN_SUSPENDED: Currently suspended at a yield expression.\n      GEN_CLOSED: Execution has completed.\n    \"\"\"\n    if generator.gi_running:\n        return GEN_RUNNING\n    if generator.gi_frame is None:\n        return GEN_CLOSED\n    if generator.gi_frame.f_lasti == -1:\n        return GEN_CREATED\n    return GEN_SUSPENDED\n\n\ndef getgeneratorlocals(generator):\n    \"\"\"\n    Get the mapping of generator local variables to their current values.\n\n    A dict is returned, with the keys the local variable names and values the\n    bound values.\"\"\"\n\n    if not isgenerator(generator):\n        raise TypeError(\"{!r} is not a Python generator\".format(generator))\n\n    frame = getattr(generator, \"gi_frame\", None)\n    if frame is not None:\n        return generator.gi_frame.f_locals\n    else:\n        return {}\n\n\n# ------------------------------------------------ coroutine introspection\n\nCORO_CREATED = 'CORO_CREATED'\nCORO_RUNNING = 'CORO_RUNNING'\nCORO_SUSPENDED = 'CORO_SUSPENDED'\nCORO_CLOSED = 'CORO_CLOSED'\n\ndef getcoroutinestate(coroutine):\n    \"\"\"Get current state of a coroutine object.\n\n    Possible states are:\n      CORO_CREATED: Waiting to start execution.\n      CORO_RUNNING: Currently being executed by the interpreter.\n      CORO_SUSPENDED: Currently suspended at an await expression.\n      CORO_CLOSED: Execution has completed.\n    \"\"\"\n    if coroutine.cr_running:\n        return CORO_RUNNING\n    if coroutine.cr_frame is None:\n        return CORO_CLOSED\n    if coroutine.cr_frame.f_lasti == -1:\n        return CORO_CREATED\n    return CORO_SUSPENDED\n\n\ndef getcoroutinelocals(coroutine):\n    \"\"\"\n    Get the mapping of coroutine local variables to their current values.\n\n    A dict is returned, with the keys the local variable names and values the\n    bound values.\"\"\"\n    frame = getattr(coroutine, \"cr_frame\", None)\n    if frame is not None:\n        return frame.f_locals\n    else:\n        return {}\n\n\n###############################################################################\n### Function Signature Object (PEP 362)\n###############################################################################\n\n\n_WrapperDescriptor = type(type.__call__)\n_MethodWrapper = type(all.__call__)\n_ClassMethodWrapper = type(int.__dict__['from_bytes'])\n\n_NonUserDefinedCallables = (_WrapperDescriptor,\n                            _MethodWrapper,\n                            _ClassMethodWrapper,\n                            types.BuiltinFunctionType)\n\n\ndef _signature_get_user_defined_method(cls, method_name):\n    \"\"\"Private helper. Checks if ``cls`` has an attribute\n    named ``method_name`` and returns it only if it is a\n    pure python function.\n    \"\"\"\n    try:\n        meth = getattr(cls, method_name)\n    except AttributeError:\n        return\n    else:\n        if not isinstance(meth, _NonUserDefinedCallables):\n            # Once '__signature__' will be added to 'C'-level\n            # callables, this check won't be necessary\n            return meth\n\n\ndef _signature_get_partial(wrapped_sig, partial, extra_args=()):\n    \"\"\"Private helper to calculate how 'wrapped_sig' signature will\n    look like after applying a 'functools.partial' object (or alike)\n    on it.\n    \"\"\"\n\n    old_params = wrapped_sig.parameters\n    new_params = OrderedDict(old_params.items())\n\n    partial_args = partial.args or ()\n    partial_keywords = partial.keywords or {}\n\n    if extra_args:\n        partial_args = extra_args + partial_args\n\n    try:\n        ba = wrapped_sig.bind_partial(*partial_args, **partial_keywords)\n    except TypeError as ex:\n        msg = 'partial object {!r} has incorrect arguments'.format(partial)\n        raise ValueError(msg) from ex\n\n\n    transform_to_kwonly = False\n    for param_name, param in old_params.items():\n        try:\n            arg_value = ba.arguments[param_name]\n        except KeyError:\n            pass\n        else:\n            if param.kind is _POSITIONAL_ONLY:\n                # If positional-only parameter is bound by partial,\n                # it effectively disappears from the signature\n                new_params.pop(param_name)\n                continue\n\n            if param.kind is _POSITIONAL_OR_KEYWORD:\n                if param_name in partial_keywords:\n                    # This means that this parameter, and all parameters\n                    # after it should be keyword-only (and var-positional\n                    # should be removed). Here's why. Consider the following\n                    # function:\n                    #     foo(a, b, *args, c):\n                    #         pass\n                    #\n                    # \"partial(foo, a='spam')\" will have the following\n                    # signature: \"(*, a='spam', b, c)\". Because attempting\n                    # to call that partial with \"(10, 20)\" arguments will\n                    # raise a TypeError, saying that \"a\" argument received\n                    # multiple values.\n                    transform_to_kwonly = True\n                    # Set the new default value\n                    new_params[param_name] = param.replace(default=arg_value)\n                else:\n                    # was passed as a positional argument\n                    new_params.pop(param.name)\n                    continue\n\n            if param.kind is _KEYWORD_ONLY:\n                # Set the new default value\n                new_params[param_name] = param.replace(default=arg_value)\n\n        if transform_to_kwonly:\n            assert param.kind is not _POSITIONAL_ONLY\n\n            if param.kind is _POSITIONAL_OR_KEYWORD:\n                new_param = new_params[param_name].replace(kind=_KEYWORD_ONLY)\n                new_params[param_name] = new_param\n                new_params.move_to_end(param_name)\n            elif param.kind in (_KEYWORD_ONLY, _VAR_KEYWORD):\n                new_params.move_to_end(param_name)\n            elif param.kind is _VAR_POSITIONAL:\n                new_params.pop(param.name)\n\n    return wrapped_sig.replace(parameters=new_params.values())\n\n\ndef _signature_bound_method(sig):\n    \"\"\"Private helper to transform signatures for unbound\n    functions to bound methods.\n    \"\"\"\n\n    params = tuple(sig.parameters.values())\n\n    if not params or params[0].kind in (_VAR_KEYWORD, _KEYWORD_ONLY):\n        raise ValueError('invalid method signature')\n\n    kind = params[0].kind\n    if kind in (_POSITIONAL_OR_KEYWORD, _POSITIONAL_ONLY):\n        # Drop first parameter:\n        # '(p1, p2[, ...])' -> '(p2[, ...])'\n        params = params[1:]\n    else:\n        if kind is not _VAR_POSITIONAL:\n            # Unless we add a new parameter type we never\n            # get here\n            raise ValueError('invalid argument type')\n        # It's a var-positional parameter.\n        # Do nothing. '(*args[, ...])' -> '(*args[, ...])'\n\n    return sig.replace(parameters=params)\n\n\ndef _signature_is_builtin(obj):\n    \"\"\"Private helper to test if `obj` is a callable that might\n    support Argument Clinic's __text_signature__ protocol.\n    \"\"\"\n    return (isbuiltin(obj) or\n            ismethoddescriptor(obj) or\n            isinstance(obj, _NonUserDefinedCallables) or\n            # Can't test 'isinstance(type)' here, as it would\n            # also be True for regular python classes\n            obj in (type, object))\n\n\ndef _signature_is_functionlike(obj):\n    \"\"\"Private helper to test if `obj` is a duck type of FunctionType.\n    A good example of such objects are functions compiled with\n    Cython, which have all attributes that a pure Python function\n    would have, but have their code statically compiled.\n    \"\"\"\n\n    if not callable(obj) or isclass(obj):\n        # All function-like objects are obviously callables,\n        # and not classes.\n        return False\n\n    name = getattr(obj, '__name__', None)\n    code = getattr(obj, '__code__', None)\n    defaults = getattr(obj, '__defaults__', _void) # Important to use _void ...\n    kwdefaults = getattr(obj, '__kwdefaults__', _void) # ... and not None here\n    annotations = getattr(obj, '__annotations__', None)\n\n    return (isinstance(code, types.CodeType) and\n            isinstance(name, str) and\n            (defaults is None or isinstance(defaults, tuple)) and\n            (kwdefaults is None or isinstance(kwdefaults, dict)) and\n            isinstance(annotations, dict))\n\n\ndef _signature_get_bound_param(spec):\n    \"\"\" Private helper to get first parameter name from a\n    __text_signature__ of a builtin method, which should\n    be in the following format: '($param1, ...)'.\n    Assumptions are that the first argument won't have\n    a default value or an annotation.\n    \"\"\"\n\n    assert spec.startswith('($')\n\n    pos = spec.find(',')\n    if pos == -1:\n        pos = spec.find(')')\n\n    cpos = spec.find(':')\n    assert cpos == -1 or cpos > pos\n\n    cpos = spec.find('=')\n    assert cpos == -1 or cpos > pos\n\n    return spec[2:pos]\n\n\ndef _signature_strip_non_python_syntax(signature):\n    \"\"\"\n    Private helper function. Takes a signature in Argument Clinic's\n    extended signature format.\n\n    Returns a tuple of three things:\n      * that signature re-rendered in standard Python syntax,\n      * the index of the \"self\" parameter (generally 0), or None if\n        the function does not have a \"self\" parameter, and\n      * the index of the last \"positional only\" parameter,\n        or None if the signature has no positional-only parameters.\n    \"\"\"\n\n    if not signature:\n        return signature, None, None\n\n    self_parameter = None\n    last_positional_only = None\n\n    lines = [l.encode('ascii') for l in signature.split('\\n')]\n    generator = iter(lines).__next__\n    token_stream = tokenize.tokenize(generator)\n\n    delayed_comma = False\n    skip_next_comma = False\n    text = []\n    add = text.append\n\n    current_parameter = 0\n    OP = token.OP\n    ERRORTOKEN = token.ERRORTOKEN\n\n    # token stream always starts with ENCODING token, skip it\n    t = next(token_stream)\n    assert t.type == tokenize.ENCODING\n\n    for t in token_stream:\n        type, string = t.type, t.string\n\n        if type == OP:\n            if string == ',':\n                if skip_next_comma:\n                    skip_next_comma = False\n                else:\n                    assert not delayed_comma\n                    delayed_comma = True\n                    current_parameter += 1\n                continue\n\n            if string == '/':\n                assert not skip_next_comma\n                assert last_positional_only is None\n                skip_next_comma = True\n                last_positional_only = current_parameter - 1\n                continue\n\n        if (type == ERRORTOKEN) and (string == '$'):\n            assert self_parameter is None\n            self_parameter = current_parameter\n            continue\n\n        if delayed_comma:\n            delayed_comma = False\n            if not ((type == OP) and (string == ')')):\n                add(', ')\n        add(string)\n        if (string == ','):\n            add(' ')\n    clean_signature = ''.join(text)\n    return clean_signature, self_parameter, last_positional_only\n\n\ndef _signature_fromstr(cls, obj, s, skip_bound_arg=True):\n    \"\"\"Private helper to parse content of '__text_signature__'\n    and return a Signature based on it.\n    \"\"\"\n    # Lazy import ast because it's relatively heavy and\n    # it's not used for other than this function.\n    import ast\n\n    Parameter = cls._parameter_cls\n\n    clean_signature, self_parameter, last_positional_only = \\\n        _signature_strip_non_python_syntax(s)\n\n    program = \"def foo\" + clean_signature + \": pass\"\n\n    try:\n        module = ast.parse(program)\n    except SyntaxError:\n        module = None\n\n    if not isinstance(module, ast.Module):\n        raise ValueError(\"{!r} builtin has invalid signature\".format(obj))\n\n    f = module.body[0]\n\n    parameters = []\n    empty = Parameter.empty\n    invalid = object()\n\n    module = None\n    module_dict = {}\n    module_name = getattr(obj, '__module__', None)\n    if module_name:\n        module = sys.modules.get(module_name, None)\n        if module:\n            module_dict = module.__dict__\n    sys_module_dict = sys.modules.copy()\n\n    def parse_name(node):\n        assert isinstance(node, ast.arg)\n        if node.annotation is not None:\n            raise ValueError(\"Annotations are not currently supported\")\n        return node.arg\n\n    def wrap_value(s):\n        try:\n            value = eval(s, module_dict)\n        except NameError:\n            try:\n                value = eval(s, sys_module_dict)\n            except NameError:\n                raise RuntimeError()\n\n        if isinstance(value, (str, int, float, bytes, bool, type(None))):\n            return ast.Constant(value)\n        raise RuntimeError()\n\n    class RewriteSymbolics(ast.NodeTransformer):\n        def visit_Attribute(self, node):\n            a = []\n            n = node\n            while isinstance(n, ast.Attribute):\n                a.append(n.attr)\n                n = n.value\n            if not isinstance(n, ast.Name):\n                raise RuntimeError()\n            a.append(n.id)\n            value = \".\".join(reversed(a))\n            return wrap_value(value)\n\n        def visit_Name(self, node):\n            if not isinstance(node.ctx, ast.Load):\n                raise ValueError()\n            return wrap_value(node.id)\n\n    def p(name_node, default_node, default=empty):\n        name = parse_name(name_node)\n        if name is invalid:\n            return None\n        if default_node and default_node is not _empty:\n            try:\n                default_node = RewriteSymbolics().visit(default_node)\n                o = ast.literal_eval(default_node)\n            except ValueError:\n                o = invalid\n            if o is invalid:\n                return None\n            default = o if o is not invalid else default\n        parameters.append(Parameter(name, kind, default=default, annotation=empty))\n\n    # non-keyword-only parameters\n    args = reversed(f.args.args)\n    defaults = reversed(f.args.defaults)\n    iter = itertools.zip_longest(args, defaults, fillvalue=None)\n    if last_positional_only is not None:\n        kind = Parameter.POSITIONAL_ONLY\n    else:\n        kind = Parameter.POSITIONAL_OR_KEYWORD\n    for i, (name, default) in enumerate(reversed(list(iter))):\n        p(name, default)\n        if i == last_positional_only:\n            kind = Parameter.POSITIONAL_OR_KEYWORD\n\n    # *args\n    if f.args.vararg:\n        kind = Parameter.VAR_POSITIONAL\n        p(f.args.vararg, empty)\n\n    # keyword-only arguments\n    kind = Parameter.KEYWORD_ONLY\n    for name, default in zip(f.args.kwonlyargs, f.args.kw_defaults):\n        p(name, default)\n\n    # **kwargs\n    if f.args.kwarg:\n        kind = Parameter.VAR_KEYWORD\n        p(f.args.kwarg, empty)\n\n    if self_parameter is not None:\n        # Possibly strip the bound argument:\n        #    - We *always* strip first bound argument if\n        #      it is a module.\n        #    - We don't strip first bound argument if\n        #      skip_bound_arg is False.\n        assert parameters\n        _self = getattr(obj, '__self__', None)\n        self_isbound = _self is not None\n        self_ismodule = ismodule(_self)\n        if self_isbound and (self_ismodule or skip_bound_arg):\n            parameters.pop(0)\n        else:\n            # for builtins, self parameter is always positional-only!\n            p = parameters[0].replace(kind=Parameter.POSITIONAL_ONLY)\n            parameters[0] = p\n\n    return cls(parameters, return_annotation=cls.empty)\n\n\ndef _signature_from_builtin(cls, func, skip_bound_arg=True):\n    \"\"\"Private helper function to get signature for\n    builtin callables.\n    \"\"\"\n\n    if not _signature_is_builtin(func):\n        raise TypeError(\"{!r} is not a Python builtin \"\n                        \"function\".format(func))\n\n    s = getattr(func, \"__text_signature__\", None)\n    if not s:\n        raise ValueError(\"no signature found for builtin {!r}\".format(func))\n\n    return _signature_fromstr(cls, func, s, skip_bound_arg)\n\n\ndef _signature_from_function(cls, func, skip_bound_arg=True):\n    \"\"\"Private helper: constructs Signature for the given python function.\"\"\"\n\n    is_duck_function = False\n    if not isfunction(func):\n        if _signature_is_functionlike(func):\n            is_duck_function = True\n        else:\n            # If it's not a pure Python function, and not a duck type\n            # of pure function:\n            raise TypeError('{!r} is not a Python function'.format(func))\n\n    s = getattr(func, \"__text_signature__\", None)\n    if s:\n        return _signature_fromstr(cls, func, s, skip_bound_arg)\n\n    Parameter = cls._parameter_cls\n\n    # Parameter information.\n    func_code = func.__code__\n    pos_count = func_code.co_argcount\n    arg_names = func_code.co_varnames\n    posonly_count = func_code.co_posonlyargcount\n    positional = arg_names[:pos_count]\n    keyword_only_count = func_code.co_kwonlyargcount\n    keyword_only = arg_names[pos_count:pos_count + keyword_only_count]\n    annotations = func.__annotations__\n    defaults = func.__defaults__\n    kwdefaults = func.__kwdefaults__\n\n    if defaults:\n        pos_default_count = len(defaults)\n    else:\n        pos_default_count = 0\n\n    parameters = []\n\n    non_default_count = pos_count - pos_default_count\n    posonly_left = posonly_count\n\n    # Non-keyword-only parameters w/o defaults.\n    for name in positional[:non_default_count]:\n        kind = _POSITIONAL_ONLY if posonly_left else _POSITIONAL_OR_KEYWORD\n        annotation = annotations.get(name, _empty)\n        parameters.append(Parameter(name, annotation=annotation,\n                                    kind=kind))\n        if posonly_left:\n            posonly_left -= 1\n\n    # ... w/ defaults.\n    for offset, name in enumerate(positional[non_default_count:]):\n        kind = _POSITIONAL_ONLY if posonly_left else _POSITIONAL_OR_KEYWORD\n        annotation = annotations.get(name, _empty)\n        parameters.append(Parameter(name, annotation=annotation,\n                                    kind=kind,\n                                    default=defaults[offset]))\n        if posonly_left:\n            posonly_left -= 1\n\n    # *args\n    if func_code.co_flags & CO_VARARGS:\n        name = arg_names[pos_count + keyword_only_count]\n        annotation = annotations.get(name, _empty)\n        parameters.append(Parameter(name, annotation=annotation,\n                                    kind=_VAR_POSITIONAL))\n\n    # Keyword-only parameters.\n    for name in keyword_only:\n        default = _empty\n        if kwdefaults is not None:\n            default = kwdefaults.get(name, _empty)\n\n        annotation = annotations.get(name, _empty)\n        parameters.append(Parameter(name, annotation=annotation,\n                                    kind=_KEYWORD_ONLY,\n                                    default=default))\n    # **kwargs\n    if func_code.co_flags & CO_VARKEYWORDS:\n        index = pos_count + keyword_only_count\n        if func_code.co_flags & CO_VARARGS:\n            index += 1\n\n        name = arg_names[index]\n        annotation = annotations.get(name, _empty)\n        parameters.append(Parameter(name, annotation=annotation,\n                                    kind=_VAR_KEYWORD))\n\n    # Is 'func' is a pure Python function - don't validate the\n    # parameters list (for correct order and defaults), it should be OK.\n    return cls(parameters,\n               return_annotation=annotations.get('return', _empty),\n               __validate_parameters__=is_duck_function)\n\n\ndef _signature_from_callable(obj, *,\n                             follow_wrapper_chains=True,\n                             skip_bound_arg=True,\n                             sigcls):\n\n    \"\"\"Private helper function to get signature for arbitrary\n    callable objects.\n    \"\"\"\n\n    if not callable(obj):\n        raise TypeError('{!r} is not a callable object'.format(obj))\n\n    if isinstance(obj, types.MethodType):\n        # In this case we skip the first parameter of the underlying\n        # function (usually `self` or `cls`).\n        sig = _signature_from_callable(\n            obj.__func__,\n            follow_wrapper_chains=follow_wrapper_chains,\n            skip_bound_arg=skip_bound_arg,\n            sigcls=sigcls)\n\n        if skip_bound_arg:\n            return _signature_bound_method(sig)\n        else:\n            return sig\n\n    # Was this function wrapped by a decorator?\n    if follow_wrapper_chains:\n        obj = unwrap(obj, stop=(lambda f: hasattr(f, \"__signature__\")))\n        if isinstance(obj, types.MethodType):\n            # If the unwrapped object is a *method*, we might want to\n            # skip its first parameter (self).\n            # See test_signature_wrapped_bound_method for details.\n            return _signature_from_callable(\n                obj,\n                follow_wrapper_chains=follow_wrapper_chains,\n                skip_bound_arg=skip_bound_arg,\n                sigcls=sigcls)\n\n    try:\n        sig = obj.__signature__\n    except AttributeError:\n        pass\n    else:\n        if sig is not None:\n            if not isinstance(sig, Signature):\n                raise TypeError(\n                    'unexpected object {!r} in __signature__ '\n                    'attribute'.format(sig))\n            return sig\n\n    try:\n        partialmethod = obj._partialmethod\n    except AttributeError:\n        pass\n    else:\n        if isinstance(partialmethod, functools.partialmethod):\n            # Unbound partialmethod (see functools.partialmethod)\n            # This means, that we need to calculate the signature\n            # as if it's a regular partial object, but taking into\n            # account that the first positional argument\n            # (usually `self`, or `cls`) will not be passed\n            # automatically (as for boundmethods)\n\n            wrapped_sig = _signature_from_callable(\n                partialmethod.func,\n                follow_wrapper_chains=follow_wrapper_chains,\n                skip_bound_arg=skip_bound_arg,\n                sigcls=sigcls)\n\n            sig = _signature_get_partial(wrapped_sig, partialmethod, (None,))\n            first_wrapped_param = tuple(wrapped_sig.parameters.values())[0]\n            if first_wrapped_param.kind is Parameter.VAR_POSITIONAL:\n                # First argument of the wrapped callable is `*args`, as in\n                # `partialmethod(lambda *args)`.\n                return sig\n            else:\n                sig_params = tuple(sig.parameters.values())\n                assert (not sig_params or\n                        first_wrapped_param is not sig_params[0])\n                new_params = (first_wrapped_param,) + sig_params\n                return sig.replace(parameters=new_params)\n\n    if isfunction(obj) or _signature_is_functionlike(obj):\n        # If it's a pure Python function, or an object that is duck type\n        # of a Python function (Cython functions, for instance), then:\n        return _signature_from_function(sigcls, obj,\n                                        skip_bound_arg=skip_bound_arg)\n\n    if _signature_is_builtin(obj):\n        return _signature_from_builtin(sigcls, obj,\n                                       skip_bound_arg=skip_bound_arg)\n\n    if isinstance(obj, functools.partial):\n        wrapped_sig = _signature_from_callable(\n            obj.func,\n            follow_wrapper_chains=follow_wrapper_chains,\n            skip_bound_arg=skip_bound_arg,\n            sigcls=sigcls)\n        return _signature_get_partial(wrapped_sig, obj)\n\n    sig = None\n    if isinstance(obj, type):\n        # obj is a class or a metaclass\n\n        # First, let's see if it has an overloaded __call__ defined\n        # in its metaclass\n        call = _signature_get_user_defined_method(type(obj), '__call__')\n        if call is not None:\n            sig = _signature_from_callable(\n                call,\n                follow_wrapper_chains=follow_wrapper_chains,\n                skip_bound_arg=skip_bound_arg,\n                sigcls=sigcls)\n        else:\n            # Now we check if the 'obj' class has a '__new__' method\n            new = _signature_get_user_defined_method(obj, '__new__')\n            if new is not None:\n                sig = _signature_from_callable(\n                    new,\n                    follow_wrapper_chains=follow_wrapper_chains,\n                    skip_bound_arg=skip_bound_arg,\n                    sigcls=sigcls)\n            else:\n                # Finally, we should have at least __init__ implemented\n                init = _signature_get_user_defined_method(obj, '__init__')\n                if init is not None:\n                    sig = _signature_from_callable(\n                        init,\n                        follow_wrapper_chains=follow_wrapper_chains,\n                        skip_bound_arg=skip_bound_arg,\n                        sigcls=sigcls)\n\n        if sig is None:\n            # At this point we know, that `obj` is a class, with no user-\n            # defined '__init__', '__new__', or class-level '__call__'\n\n            for base in obj.__mro__[:-1]:\n                # Since '__text_signature__' is implemented as a\n                # descriptor that extracts text signature from the\n                # class docstring, if 'obj' is derived from a builtin\n                # class, its own '__text_signature__' may be 'None'.\n                # Therefore, we go through the MRO (except the last\n                # class in there, which is 'object') to find the first\n                # class with non-empty text signature.\n                try:\n                    text_sig = base.__text_signature__\n                except AttributeError:\n                    pass\n                else:\n                    if text_sig:\n                        # If 'obj' class has a __text_signature__ attribute:\n                        # return a signature based on it\n                        return _signature_fromstr(sigcls, obj, text_sig)\n\n            # No '__text_signature__' was found for the 'obj' class.\n            # Last option is to check if its '__init__' is\n            # object.__init__ or type.__init__.\n            if type not in obj.__mro__:\n                # We have a class (not metaclass), but no user-defined\n                # __init__ or __new__ for it\n                if (obj.__init__ is object.__init__ and\n                    obj.__new__ is object.__new__):\n                    # Return a signature of 'object' builtin.\n                    return sigcls.from_callable(object)\n                else:\n                    raise ValueError(\n                        'no signature found for builtin type {!r}'.format(obj))\n\n    elif not isinstance(obj, _NonUserDefinedCallables):\n        # An object with __call__\n        # We also check that the 'obj' is not an instance of\n        # _WrapperDescriptor or _MethodWrapper to avoid\n        # infinite recursion (and even potential segfault)\n        call = _signature_get_user_defined_method(type(obj), '__call__')\n        if call is not None:\n            try:\n                sig = _signature_from_callable(\n                    call,\n                    follow_wrapper_chains=follow_wrapper_chains,\n                    skip_bound_arg=skip_bound_arg,\n                    sigcls=sigcls)\n            except ValueError as ex:\n                msg = 'no signature found for {!r}'.format(obj)\n                raise ValueError(msg) from ex\n\n    if sig is not None:\n        # For classes and objects we skip the first parameter of their\n        # __call__, __new__, or __init__ methods\n        if skip_bound_arg:\n            return _signature_bound_method(sig)\n        else:\n            return sig\n\n    if isinstance(obj, types.BuiltinFunctionType):\n        # Raise a nicer error message for builtins\n        msg = 'no signature found for builtin function {!r}'.format(obj)\n        raise ValueError(msg)\n\n    raise ValueError('callable {!r} is not supported by signature'.format(obj))\n\n\nclass _void:\n    \"\"\"A private marker - used in Parameter & Signature.\"\"\"\n\n\nclass _empty:\n    \"\"\"Marker object for Signature.empty and Parameter.empty.\"\"\"\n\n\nclass _ParameterKind(enum.IntEnum):\n    POSITIONAL_ONLY = 0\n    POSITIONAL_OR_KEYWORD = 1\n    VAR_POSITIONAL = 2\n    KEYWORD_ONLY = 3\n    VAR_KEYWORD = 4\n\n    def __str__(self):\n        return self._name_\n\n    @property\n    def description(self):\n        return _PARAM_NAME_MAPPING[self]\n\n_POSITIONAL_ONLY         = _ParameterKind.POSITIONAL_ONLY\n_POSITIONAL_OR_KEYWORD   = _ParameterKind.POSITIONAL_OR_KEYWORD\n_VAR_POSITIONAL          = _ParameterKind.VAR_POSITIONAL\n_KEYWORD_ONLY            = _ParameterKind.KEYWORD_ONLY\n_VAR_KEYWORD             = _ParameterKind.VAR_KEYWORD\n\n_PARAM_NAME_MAPPING = {\n    _POSITIONAL_ONLY: 'positional-only',\n    _POSITIONAL_OR_KEYWORD: 'positional or keyword',\n    _VAR_POSITIONAL: 'variadic positional',\n    _KEYWORD_ONLY: 'keyword-only',\n    _VAR_KEYWORD: 'variadic keyword'\n}\n\n\nclass Parameter:\n    \"\"\"Represents a parameter in a function signature.\n\n    Has the following public attributes:\n\n    * name : str\n        The name of the parameter as a string.\n    * default : object\n        The default value for the parameter if specified.  If the\n        parameter has no default value, this attribute is set to\n        `Parameter.empty`.\n    * annotation\n        The annotation for the parameter if specified.  If the\n        parameter has no annotation, this attribute is set to\n        `Parameter.empty`.\n    * kind : str\n        Describes how argument values are bound to the parameter.\n        Possible values: `Parameter.POSITIONAL_ONLY`,\n        `Parameter.POSITIONAL_OR_KEYWORD`, `Parameter.VAR_POSITIONAL`,\n        `Parameter.KEYWORD_ONLY`, `Parameter.VAR_KEYWORD`.\n    \"\"\"\n\n    __slots__ = ('_name', '_kind', '_default', '_annotation')\n\n    POSITIONAL_ONLY         = _POSITIONAL_ONLY\n    POSITIONAL_OR_KEYWORD   = _POSITIONAL_OR_KEYWORD\n    VAR_POSITIONAL          = _VAR_POSITIONAL\n    KEYWORD_ONLY            = _KEYWORD_ONLY\n    VAR_KEYWORD             = _VAR_KEYWORD\n\n    empty = _empty\n\n    def __init__(self, name, kind, *, default=_empty, annotation=_empty):\n        try:\n            self._kind = _ParameterKind(kind)\n        except ValueError:\n            raise ValueError(f'value {kind!r} is not a valid Parameter.kind')\n        if default is not _empty:\n            if self._kind in (_VAR_POSITIONAL, _VAR_KEYWORD):\n                msg = '{} parameters cannot have default values'\n                msg = msg.format(self._kind.description)\n                raise ValueError(msg)\n        self._default = default\n        self._annotation = annotation\n\n        if name is _empty:\n            raise ValueError('name is a required attribute for Parameter')\n\n        if not isinstance(name, str):\n            msg = 'name must be a str, not a {}'.format(type(name).__name__)\n            raise TypeError(msg)\n\n        if name[0] == '.' and name[1:].isdigit():\n            # These are implicit arguments generated by comprehensions. In\n            # order to provide a friendlier interface to users, we recast\n            # their name as \"implicitN\" and treat them as positional-only.\n            # See issue 19611.\n            if self._kind != _POSITIONAL_OR_KEYWORD:\n                msg = (\n                    'implicit arguments must be passed as '\n                    'positional or keyword arguments, not {}'\n                )\n                msg = msg.format(self._kind.description)\n                raise ValueError(msg)\n            self._kind = _POSITIONAL_ONLY\n            name = 'implicit{}'.format(name[1:])\n\n        if not name.isidentifier():\n            raise ValueError('{!r} is not a valid parameter name'.format(name))\n\n        self._name = name\n\n    def __reduce__(self):\n        return (type(self),\n                (self._name, self._kind),\n                {'_default': self._default,\n                 '_annotation': self._annotation})\n\n    def __setstate__(self, state):\n        self._default = state['_default']\n        self._annotation = state['_annotation']\n\n    @property\n    def name(self):\n        return self._name\n\n    @property\n    def default(self):\n        return self._default\n\n    @property\n    def annotation(self):\n        return self._annotation\n\n    @property\n    def kind(self):\n        return self._kind\n\n    def replace(self, *, name=_void, kind=_void,\n                annotation=_void, default=_void):\n        \"\"\"Creates a customized copy of the Parameter.\"\"\"\n\n        if name is _void:\n            name = self._name\n\n        if kind is _void:\n            kind = self._kind\n\n        if annotation is _void:\n            annotation = self._annotation\n\n        if default is _void:\n            default = self._default\n\n        return type(self)(name, kind, default=default, annotation=annotation)\n\n    def __str__(self):\n        kind = self.kind\n        formatted = self._name\n\n        # Add annotation and default value\n        if self._annotation is not _empty:\n            formatted = '{}: {}'.format(formatted,\n                                       formatannotation(self._annotation))\n\n        if self._default is not _empty:\n            if self._annotation is not _empty:\n                formatted = '{} = {}'.format(formatted, repr(self._default))\n            else:\n                formatted = '{}={}'.format(formatted, repr(self._default))\n\n        if kind == _VAR_POSITIONAL:\n            formatted = '*' + formatted\n        elif kind == _VAR_KEYWORD:\n            formatted = '**' + formatted\n\n        return formatted\n\n    def __repr__(self):\n        return '<{} \"{}\">'.format(self.__class__.__name__, self)\n\n    def __hash__(self):\n        return hash((self.name, self.kind, self.annotation, self.default))\n\n    def __eq__(self, other):\n        if self is other:\n            return True\n        if not isinstance(other, Parameter):\n            return NotImplemented\n        return (self._name == other._name and\n                self._kind == other._kind and\n                self._default == other._default and\n                self._annotation == other._annotation)\n\n\nclass BoundArguments:\n    \"\"\"Result of `Signature.bind` call.  Holds the mapping of arguments\n    to the function's parameters.\n\n    Has the following public attributes:\n\n    * arguments : OrderedDict\n        An ordered mutable mapping of parameters' names to arguments' values.\n        Does not contain arguments' default values.\n    * signature : Signature\n        The Signature object that created this instance.\n    * args : tuple\n        Tuple of positional arguments values.\n    * kwargs : dict\n        Dict of keyword arguments values.\n    \"\"\"\n\n    __slots__ = ('arguments', '_signature', '__weakref__')\n\n    def __init__(self, signature, arguments):\n        self.arguments = arguments\n        self._signature = signature\n\n    @property\n    def signature(self):\n        return self._signature\n\n    @property\n    def args(self):\n        args = []\n        for param_name, param in self._signature.parameters.items():\n            if param.kind in (_VAR_KEYWORD, _KEYWORD_ONLY):\n                break\n\n            try:\n                arg = self.arguments[param_name]\n            except KeyError:\n                # We're done here. Other arguments\n                # will be mapped in 'BoundArguments.kwargs'\n                break\n            else:\n                if param.kind == _VAR_POSITIONAL:\n                    # *args\n                    args.extend(arg)\n                else:\n                    # plain argument\n                    args.append(arg)\n\n        return tuple(args)\n\n    @property\n    def kwargs(self):\n        kwargs = {}\n        kwargs_started = False\n        for param_name, param in self._signature.parameters.items():\n            if not kwargs_started:\n                if param.kind in (_VAR_KEYWORD, _KEYWORD_ONLY):\n                    kwargs_started = True\n                else:\n                    if param_name not in self.arguments:\n                        kwargs_started = True\n                        continue\n\n            if not kwargs_started:\n                continue\n\n            try:\n                arg = self.arguments[param_name]\n            except KeyError:\n                pass\n            else:\n                if param.kind == _VAR_KEYWORD:\n                    # **kwargs\n                    kwargs.update(arg)\n                else:\n                    # plain keyword argument\n                    kwargs[param_name] = arg\n\n        return kwargs\n\n    def apply_defaults(self):\n        \"\"\"Set default values for missing arguments.\n\n        For variable-positional arguments (*args) the default is an\n        empty tuple.\n\n        For variable-keyword arguments (**kwargs) the default is an\n        empty dict.\n        \"\"\"\n        arguments = self.arguments\n        new_arguments = []\n        for name, param in self._signature.parameters.items():\n            try:\n                new_arguments.append((name, arguments[name]))\n            except KeyError:\n                if param.default is not _empty:\n                    val = param.default\n                elif param.kind is _VAR_POSITIONAL:\n                    val = ()\n                elif param.kind is _VAR_KEYWORD:\n                    val = {}\n                else:\n                    # This BoundArguments was likely produced by\n                    # Signature.bind_partial().\n                    continue\n                new_arguments.append((name, val))\n        self.arguments = OrderedDict(new_arguments)\n\n    def __eq__(self, other):\n        if self is other:\n            return True\n        if not isinstance(other, BoundArguments):\n            return NotImplemented\n        return (self.signature == other.signature and\n                self.arguments == other.arguments)\n\n    def __setstate__(self, state):\n        self._signature = state['_signature']\n        self.arguments = state['arguments']\n\n    def __getstate__(self):\n        return {'_signature': self._signature, 'arguments': self.arguments}\n\n    def __repr__(self):\n        args = []\n        for arg, value in self.arguments.items():\n            args.append('{}={!r}'.format(arg, value))\n        return '<{} ({})>'.format(self.__class__.__name__, ', '.join(args))\n\n\nclass Signature:\n    \"\"\"A Signature object represents the overall signature of a function.\n    It stores a Parameter object for each parameter accepted by the\n    function, as well as information specific to the function itself.\n\n    A Signature object has the following public attributes and methods:\n\n    * parameters : OrderedDict\n        An ordered mapping of parameters' names to the corresponding\n        Parameter objects (keyword-only arguments are in the same order\n        as listed in `code.co_varnames`).\n    * return_annotation : object\n        The annotation for the return type of the function if specified.\n        If the function has no annotation for its return type, this\n        attribute is set to `Signature.empty`.\n    * bind(*args, **kwargs) -> BoundArguments\n        Creates a mapping from positional and keyword arguments to\n        parameters.\n    * bind_partial(*args, **kwargs) -> BoundArguments\n        Creates a partial mapping from positional and keyword arguments\n        to parameters (simulating 'functools.partial' behavior.)\n    \"\"\"\n\n    __slots__ = ('_return_annotation', '_parameters')\n\n    _parameter_cls = Parameter\n    _bound_arguments_cls = BoundArguments\n\n    empty = _empty\n\n    def __init__(self, parameters=None, *, return_annotation=_empty,\n                 __validate_parameters__=True):\n        \"\"\"Constructs Signature from the given list of Parameter\n        objects and 'return_annotation'.  All arguments are optional.\n        \"\"\"\n\n        if parameters is None:\n            params = OrderedDict()\n        else:\n            if __validate_parameters__:\n                params = OrderedDict()\n                top_kind = _POSITIONAL_ONLY\n                kind_defaults = False\n\n                for idx, param in enumerate(parameters):\n                    kind = param.kind\n                    name = param.name\n\n                    if kind < top_kind:\n                        msg = (\n                            'wrong parameter order: {} parameter before {} '\n                            'parameter'\n                        )\n                        msg = msg.format(top_kind.description,\n                                         kind.description)\n                        raise ValueError(msg)\n                    elif kind > top_kind:\n                        kind_defaults = False\n                        top_kind = kind\n\n                    if kind in (_POSITIONAL_ONLY, _POSITIONAL_OR_KEYWORD):\n                        if param.default is _empty:\n                            if kind_defaults:\n                                # No default for this parameter, but the\n                                # previous parameter of the same kind had\n                                # a default\n                                msg = 'non-default argument follows default ' \\\n                                      'argument'\n                                raise ValueError(msg)\n                        else:\n                            # There is a default for this parameter.\n                            kind_defaults = True\n\n                    if name in params:\n                        msg = 'duplicate parameter name: {!r}'.format(name)\n                        raise ValueError(msg)\n\n                    params[name] = param\n            else:\n                params = OrderedDict(((param.name, param)\n                                                for param in parameters))\n\n        self._parameters = types.MappingProxyType(params)\n        self._return_annotation = return_annotation\n\n    @classmethod\n    def from_function(cls, func):\n        \"\"\"Constructs Signature for the given python function.\n\n        Deprecated since Python 3.5, use `Signature.from_callable()`.\n        \"\"\"\n\n        warnings.warn(\"inspect.Signature.from_function() is deprecated since \"\n                      \"Python 3.5, use Signature.from_callable()\",\n                      DeprecationWarning, stacklevel=2)\n        return _signature_from_function(cls, func)\n\n    @classmethod\n    def from_builtin(cls, func):\n        \"\"\"Constructs Signature for the given builtin function.\n\n        Deprecated since Python 3.5, use `Signature.from_callable()`.\n        \"\"\"\n\n        warnings.warn(\"inspect.Signature.from_builtin() is deprecated since \"\n                      \"Python 3.5, use Signature.from_callable()\",\n                      DeprecationWarning, stacklevel=2)\n        return _signature_from_builtin(cls, func)\n\n    @classmethod\n    def from_callable(cls, obj, *, follow_wrapped=True):\n        \"\"\"Constructs Signature for the given callable object.\"\"\"\n        return _signature_from_callable(obj, sigcls=cls,\n                                        follow_wrapper_chains=follow_wrapped)\n\n    @property\n    def parameters(self):\n        return self._parameters\n\n    @property\n    def return_annotation(self):\n        return self._return_annotation\n\n    def replace(self, *, parameters=_void, return_annotation=_void):\n        \"\"\"Creates a customized copy of the Signature.\n        Pass 'parameters' and/or 'return_annotation' arguments\n        to override them in the new copy.\n        \"\"\"\n\n        if parameters is _void:\n            parameters = self.parameters.values()\n\n        if return_annotation is _void:\n            return_annotation = self._return_annotation\n\n        return type(self)(parameters,\n                          return_annotation=return_annotation)\n\n    def _hash_basis(self):\n        params = tuple(param for param in self.parameters.values()\n                             if param.kind != _KEYWORD_ONLY)\n\n        kwo_params = {param.name: param for param in self.parameters.values()\n                                        if param.kind == _KEYWORD_ONLY}\n\n        return params, kwo_params, self.return_annotation\n\n    def __hash__(self):\n        params, kwo_params, return_annotation = self._hash_basis()\n        kwo_params = frozenset(kwo_params.values())\n        return hash((params, kwo_params, return_annotation))\n\n    def __eq__(self, other):\n        if self is other:\n            return True\n        if not isinstance(other, Signature):\n            return NotImplemented\n        return self._hash_basis() == other._hash_basis()\n\n    def _bind(self, args, kwargs, *, partial=False):\n        \"\"\"Private method. Don't use directly.\"\"\"\n\n        arguments = OrderedDict()\n\n        parameters = iter(self.parameters.values())\n        parameters_ex = ()\n        arg_vals = iter(args)\n\n        while True:\n            # Let's iterate through the positional arguments and corresponding\n            # parameters\n            try:\n                arg_val = next(arg_vals)\n            except StopIteration:\n                # No more positional arguments\n                try:\n                    param = next(parameters)\n                except StopIteration:\n                    # No more parameters. That's it. Just need to check that\n                    # we have no `kwargs` after this while loop\n                    break\n                else:\n                    if param.kind == _VAR_POSITIONAL:\n                        # That's OK, just empty *args.  Let's start parsing\n                        # kwargs\n                        break\n                    elif param.name in kwargs:\n                        if param.kind == _POSITIONAL_ONLY:\n                            msg = '{arg!r} parameter is positional only, ' \\\n                                  'but was passed as a keyword'\n                            msg = msg.format(arg=param.name)\n                            raise TypeError(msg) from None\n                        parameters_ex = (param,)\n                        break\n                    elif (param.kind == _VAR_KEYWORD or\n                                                param.default is not _empty):\n                        # That's fine too - we have a default value for this\n                        # parameter.  So, lets start parsing `kwargs`, starting\n                        # with the current parameter\n                        parameters_ex = (param,)\n                        break\n                    else:\n                        # No default, not VAR_KEYWORD, not VAR_POSITIONAL,\n                        # not in `kwargs`\n                        if partial:\n                            parameters_ex = (param,)\n                            break\n                        else:\n                            msg = 'missing a required argument: {arg!r}'\n                            msg = msg.format(arg=param.name)\n                            raise TypeError(msg) from None\n            else:\n                # We have a positional argument to process\n                try:\n                    param = next(parameters)\n                except StopIteration:\n                    raise TypeError('too many positional arguments') from None\n                else:\n                    if param.kind in (_VAR_KEYWORD, _KEYWORD_ONLY):\n                        # Looks like we have no parameter for this positional\n                        # argument\n                        raise TypeError(\n                            'too many positional arguments') from None\n\n                    if param.kind == _VAR_POSITIONAL:\n                        # We have an '*args'-like argument, let's fill it with\n                        # all positional arguments we have left and move on to\n                        # the next phase\n                        values = [arg_val]\n                        values.extend(arg_vals)\n                        arguments[param.name] = tuple(values)\n                        break\n\n                    if param.name in kwargs and param.kind != _POSITIONAL_ONLY:\n                        raise TypeError(\n                            'multiple values for argument {arg!r}'.format(\n                                arg=param.name)) from None\n\n                    arguments[param.name] = arg_val\n\n        # Now, we iterate through the remaining parameters to process\n        # keyword arguments\n        kwargs_param = None\n        for param in itertools.chain(parameters_ex, parameters):\n            if param.kind == _VAR_KEYWORD:\n                # Memorize that we have a '**kwargs'-like parameter\n                kwargs_param = param\n                continue\n\n            if param.kind == _VAR_POSITIONAL:\n                # Named arguments don't refer to '*args'-like parameters.\n                # We only arrive here if the positional arguments ended\n                # before reaching the last parameter before *args.\n                continue\n\n            param_name = param.name\n            try:\n                arg_val = kwargs.pop(param_name)\n            except KeyError:\n                # We have no value for this parameter.  It's fine though,\n                # if it has a default value, or it is an '*args'-like\n                # parameter, left alone by the processing of positional\n                # arguments.\n                if (not partial and param.kind != _VAR_POSITIONAL and\n                                                    param.default is _empty):\n                    raise TypeError('missing a required argument: {arg!r}'. \\\n                                    format(arg=param_name)) from None\n\n            else:\n                if param.kind == _POSITIONAL_ONLY:\n                    # This should never happen in case of a properly built\n                    # Signature object (but let's have this check here\n                    # to ensure correct behaviour just in case)\n                    raise TypeError('{arg!r} parameter is positional only, '\n                                    'but was passed as a keyword'. \\\n                                    format(arg=param.name))\n\n                arguments[param_name] = arg_val\n\n        if kwargs:\n            if kwargs_param is not None:\n                # Process our '**kwargs'-like parameter\n                arguments[kwargs_param.name] = kwargs\n            else:\n                raise TypeError(\n                    'got an unexpected keyword argument {arg!r}'.format(\n                        arg=next(iter(kwargs))))\n\n        return self._bound_arguments_cls(self, arguments)\n\n    def bind(self, /, *args, **kwargs):\n        \"\"\"Get a BoundArguments object, that maps the passed `args`\n        and `kwargs` to the function's signature.  Raises `TypeError`\n        if the passed arguments can not be bound.\n        \"\"\"\n        return self._bind(args, kwargs)\n\n    def bind_partial(self, /, *args, **kwargs):\n        \"\"\"Get a BoundArguments object, that partially maps the\n        passed `args` and `kwargs` to the function's signature.\n        Raises `TypeError` if the passed arguments can not be bound.\n        \"\"\"\n        return self._bind(args, kwargs, partial=True)\n\n    def __reduce__(self):\n        return (type(self),\n                (tuple(self._parameters.values()),),\n                {'_return_annotation': self._return_annotation})\n\n    def __setstate__(self, state):\n        self._return_annotation = state['_return_annotation']\n\n    def __repr__(self):\n        return '<{} {}>'.format(self.__class__.__name__, self)\n\n    def __str__(self):\n        result = []\n        render_pos_only_separator = False\n        render_kw_only_separator = True\n        for param in self.parameters.values():\n            formatted = str(param)\n\n            kind = param.kind\n\n            if kind == _POSITIONAL_ONLY:\n                render_pos_only_separator = True\n            elif render_pos_only_separator:\n                # It's not a positional-only parameter, and the flag\n                # is set to 'True' (there were pos-only params before.)\n                result.append('/')\n                render_pos_only_separator = False\n\n            if kind == _VAR_POSITIONAL:\n                # OK, we have an '*args'-like parameter, so we won't need\n                # a '*' to separate keyword-only arguments\n                render_kw_only_separator = False\n            elif kind == _KEYWORD_ONLY and render_kw_only_separator:\n                # We have a keyword-only parameter to render and we haven't\n                # rendered an '*args'-like parameter before, so add a '*'\n                # separator to the parameters list (\"foo(arg1, *, arg2)\" case)\n                result.append('*')\n                # This condition should be only triggered once, so\n                # reset the flag\n                render_kw_only_separator = False\n\n            result.append(formatted)\n\n        if render_pos_only_separator:\n            # There were only positional-only parameters, hence the\n            # flag was not reset to 'False'\n            result.append('/')\n\n        rendered = '({})'.format(', '.join(result))\n\n        if self.return_annotation is not _empty:\n            anno = formatannotation(self.return_annotation)\n            rendered += ' -> {}'.format(anno)\n\n        return rendered\n\n\ndef signature(obj, *, follow_wrapped=True):\n    \"\"\"Get a signature object for the passed callable.\"\"\"\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n\n\ndef _main():\n    \"\"\" Logic for inspecting an object given at command line \"\"\"\n    import argparse\n    import importlib\n\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        'object',\n         help=\"The object to be analysed. \"\n              \"It supports the 'module:qualname' syntax\")\n    parser.add_argument(\n        '-d', '--details', action='store_true',\n        help='Display info about the module rather than its source code')\n\n    args = parser.parse_args()\n\n    target = args.object\n    mod_name, has_attrs, attrs = target.partition(\":\")\n    try:\n        obj = module = importlib.import_module(mod_name)\n    except Exception as exc:\n        msg = \"Failed to import {} ({}: {})\".format(mod_name,\n                                                    type(exc).__name__,\n                                                    exc)\n        print(msg, file=sys.stderr)\n        sys.exit(2)\n\n    if has_attrs:\n        parts = attrs.split(\".\")\n        obj = module\n        for part in parts:\n            obj = getattr(obj, part)\n\n    if module.__name__ in sys.builtin_module_names:\n        print(\"Can't get info for builtin modules.\", file=sys.stderr)\n        sys.exit(1)\n\n    if args.details:\n        print('Target: {}'.format(target))\n        print('Origin: {}'.format(getsourcefile(module)))\n        print('Cached: {}'.format(module.__cached__))\n        if obj is module:\n            print('Loader: {}'.format(repr(module.__loader__)))\n            if hasattr(module, '__path__'):\n                print('Submodule search path: {}'.format(module.__path__))\n        else:\n            try:\n                __, lineno = findsource(obj)\n            except Exception:\n                pass\n            else:\n                print('Line: {}'.format(lineno))\n\n        print('\\n')\n    else:\n        print(getsource(obj))\n\n\nif __name__ == \"__main__\":\n    _main()\n",3167],"D:\\githubs\\DR\\libs\\utils\\py_logger.py":["\"\"\"\n@author shenjackyuanjie\n@contact 3695888@qq.com\n\"\"\"\n#  -------------------------------\n#  Difficult Rocket\n#  Copyright © 2021-2022 by shenjackyuanjie 3695888@qq.com\n#  All rights reserved\n#  -------------------------------\nimport re\nimport os\nimport time\nimport atexit\nimport inspect\nimport threading\n\nfrom objprint import op\nfrom time import strftime\nfrom logging import NOTSET, DEBUG, INFO, WARNING, ERROR, FATAL\nfrom types import FrameType\nfrom typing import Optional, Union, Dict, Iterable, Tuple, Any, List\n\nos.system('')\n# print(os.path.abspath(os.curdir))\n\n# 如果想要直接使用 logger 来 logging\n# 直接调用 logger.debug() 即可\n# 默认配置会有\n# ----------\n# 配置方式一\n# 直接使用 logger.Logger()\n# 将会创建一个空 logger\n# 可以自行通过\n# 配置方式二\n\n\ncolor_reset_suffix = \"\\033[0m\"\n\"\"\" 只是用来重置颜色的后缀 \"\"\"\n\nre_find_color_code = r'\\033\\[[^\\f\\n\\r\\t\\vm]*m'\nre_color_code = re.compile(re_find_color_code)\n\n\"\"\"\nOFF > FATAL > ERROR > WARN > INFO > FINE > FINER > DEBUG > TRACE > ALL\nlogging.py\nCRITICAL = 50\nFATAL = CRITICAL\nERROR = 40\nWARNING = 30\nWARN = WARNING\nINFO = 20\nDEBUG = 10\nNOTSET = 0\n\"\"\"\nALL = NOTSET\nTRACE = 5\nFINE = 7\n\nlevel_name_map = {\n    ALL:     'ALL',  # NOTSET\n    TRACE:   'TRACE',\n    FINE:    'FINE',\n    DEBUG:   'DEBUG',\n    INFO:    'INFO',\n    WARNING: 'WARNING',  # WARN\n    ERROR:   'ERROR',\n    FATAL:   'FATAL'\n}\n\nname_level_map = {\n    'NOTSET':   ALL,\n    'ALL':      ALL,\n    'TRACE':    TRACE,\n    'FINE':     FINE,\n    'DEBUG':    DEBUG,\n    'INFO':     INFO,\n    'WARNING':  WARNING,\n    'WARN':     WARNING,\n    'ERROR':    ERROR,\n    'CRITICAL': FATAL,\n    'FATAL':    FATAL\n}\n\nlogger_configs = {\n    'Logger':    {\n        'root':   {\n            'level': TRACE,\n            'color': 'main_color',\n            'file':  'main_log_file',\n        },\n        'client': {\n            'level': TRACE,\n            'color': 'main_color',\n            # 'file':  'main_log_file',\n        },\n        'server': {\n            'level': TRACE,\n            'color': 'DiGua_color',\n            'file':  'main_log_file',\n        },\n    },\n    'Color':     {\n        'main_color':  {\n            'file_time': '\\033[38;2;201;222;56m',\n            'main_time': '\\033[38;2;201;222;56m',\n            'file_name': '\\033[38;2;0;255;180m',\n            'code_line': '\\033[38;2;0;255;180m',\n            'logger':    '\\033[0m',\n            TRACE:       {'info': '\\033[38;2;138;173;244m', 'message': '\\033[38;2;138;173;244m'},\n            FINE:        {'info': '\\033[35;48;2;44;44;54m', 'message': '\\033[35m'},\n            DEBUG:       {'info': '\\033[38;2;133;138;149m', 'message': '\\033[38;2;133;138;149m'},\n            INFO:        {'info': '\\033[0m', 'message': '\\033[0m'},\n            WARNING:     {'info': '\\033[33m', 'message': '\\033[33m'},\n            ERROR:       {'info': '\\033[31m', 'message': '\\033[31m'},\n            FATAL:       {'info': '\\033[38;2;255;255;0;48;2;120;10;10m', 'message': '\\033[38;2;255;255;0;48;2;120;10;10m'}\n        },\n        'DiGua_color': {\n            # catppuccin Macchiato\n            'file_time': '\\033[38;2;238;212;159m',\n            'main_time': '\\033[38;2;202;211;245m',\n            'file_name': '\\033[38;2;139;213;202m',\n            'code_line': '\\033[38;2;166;218;149m',\n            'logger':    '\\033[0m',\n            TRACE:       {'info': '\\033[38;2;138;173;244m', 'message': '\\033[38;2;138;173;244m'},\n            FINE:        {'info': '\\033[38;2;198;160;246m', 'message': '\\033[38;2;198;160;246m'},\n            DEBUG:       {'info': '\\033[38;2;133;138;149m', 'message': '\\033[38;2;133;138;149m'},\n            INFO:        {'info': '\\033[0m', 'message': '\\033[0m'},\n            WARNING:     {'info': '\\033[38;2;245;169;127m', 'message': '\\033[38;2;245;169;127m'},\n            ERROR:       {'info': '\\033[38;2;237;135;150m', 'message': '\\033[38;2;237;135;150m'},\n            FATAL:       {'info': '\\033[38;2;255;255;0;48;2;120;10;10m', 'message': '\\033[38;2;255;255;0;48;2;120;10;10m', 'logger': '\\033[38;2;245;189;230m'}\n        }\n    },\n    'File':      {\n        'main_log_file': {\n            'mode':       'a',\n            'encoding':   'utf-8',\n            'level':      TRACE,\n            'file_name':  './logs/{file_time}_logs.md',\n            'cache_len':  10,\n            'cache_time': 1\n        },\n    },\n    'Formatter': {\n        'MESSAGE':   {\n            'format': '[{main_time}] [{logger_name}] {level} | {file_name}:{code_line} | {message}'\n        },\n        'file_name': 'no frame',\n        'code_line': 'no frame',\n        'file_time': {'strftime': '%Y-%m-%d %H-%M'},\n        'main_time': {'strftime': '%Y-%m-%d %H-%M-%S:%%S'},  # %%S  三位毫秒\n        ...:         ...\n    }\n}\n\n\nclass ThreadLock:\n    \"\"\"一个用来 with 的线程锁\"\"\"\n\n    def __init__(self, the_lock: threading.Lock, time_out: Union[float, int] = 1 / 60) -> None:\n        self.lock = the_lock\n        self.time_out = time_out\n\n    def __enter__(self):\n        self.lock.acquire(timeout=self.time_out)\n        if not self.lock.locked():\n            raise RuntimeError(f'Lock time Out with {self.time_out}')\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        if self.lock.locked():\n            self.lock.release()\n\n\nclass ListCache:\n    \"\"\"一个线程安全的列表缓存\"\"\"\n\n    def __init__(self, lock: ThreadLock):\n        self._cache = []\n        self.with_thread_lock = lock\n\n    def append(self, value: Union[str, Iterable[str]]):\n        with self.with_thread_lock:\n            if isinstance(value, str):\n                self._cache.append(value)\n            elif isinstance(value, Iterable):\n                self._cache.append(*value)\n            else:\n                raise TypeError(f\"cache must be string or Iterable. not a {type(value)}\")\n\n    def __getitem__(self, item) -> str:\n        assert isinstance(item, int)\n        with self.with_thread_lock:\n            try:\n                return self._cache[item]\n            except IndexError as exp:\n                print(f'cache:{self.cache}')\n                raise IndexError(f'there is no cache at {item}!\\ncache:{self.cache}\\n{exp}')\n\n    def __call__(self, *args, **kwargs) -> List[str]:\n        return self.cache\n\n    def __iter__(self):\n        self._iter_len = len(self.cache)\n        return self\n\n    def __next__(self):\n        if self._iter_len == -1:\n            del self._iter_len\n            raise StopIteration('there is no more cache')\n        returns = self.cache[-self._iter_len]\n        self._iter_len -= 1\n        return returns\n\n    def __bool__(self):\n        with self.with_thread_lock:\n            return True if len(self.cache) > 0 else False\n\n    @property\n    def cache(self):\n        return self._cache\n\n    def clear(self):\n        with self.with_thread_lock:\n            self.cache.clear()\n\n\nclass LogFileCache:\n    \"\"\"日志文件缓存\"\"\"\n\n    def __init__(self, file_conf: dict):\n        \"\"\"\n\n        @param file_conf: 日志文件配置\n        \"\"\"\n        # 配置相关\n        self._logfile_name = os.path.abspath(format_str(file_conf['file_name']))  # log 文件名称\n        self.level = get_key_from_dict(file_conf, 'level', DEBUG)\n        self.file_conf = file_conf\n        self.flush_time = file_conf['cache_time']  # 缓存刷新时长\n        self.cache_entries_num = file_conf['cache_len']\n        self.started = True\n        self.running = False\n        # 同步锁\n        self.cache_lock = threading.Lock()  # 主锁\n        self.time_limit_lock = ThreadLock(self.cache_lock, time_out=1 / 60)  # 直接用于 with 的主锁\n        self.threaded_write = threading.Timer(1, self._log_file_time_write, kwargs={'thread': True})  # 基于 timer 的多线程\n        # 日志缓存表\n        self.log_cache = ListCache(self.time_limit_lock)\n        self.file_setup()\n\n    def file_setup(self):\n        cache_time = 0\n        file_type = self.logfile_name[self.logfile_name.rfind('.'):]\n        file_pure_name = self.logfile_name[:self.logfile_name.rfind('.')]\n        while os.path.isfile(self.logfile_name):\n            cache_time += 1\n            self.logfile_name = f'{file_pure_name}-{cache_time}{file_type}'\n\n    def end_thread(self) -> None:\n        \"\"\"结束日志写入进程，顺手把目前的缓存写入\"\"\"\n        self.cache_lock.acquire(blocking=True)\n        if self.running:\n            self.threaded_write.cancel()\n            self.running = False\n        self.started = False\n        self._log_file_time_write()\n        atexit.unregister(self.end_thread)\n\n    def start_thread(self) -> None:\n        self.threaded_write.start()\n        self.started = True\n        self.running = True\n        atexit.register(self.end_thread)\n\n    @property\n    def logfile_name(self) -> str:\n        self._logfile_name: str\n        return self._logfile_name\n\n    @logfile_name.setter\n    def logfile_name(self, value: str) -> None:\n        with self.time_limit_lock:\n            self._logfile_name = value\n\n    def _log_file_time_write(self, thread: bool = False) -> None:\n        \"\"\"使用 threading.Timer 调用的定时写入日志文件的函数\"\"\"\n        if self.log_cache:\n            with self.time_limit_lock:\n                if self.log_cache:\n                    with open(file=self.logfile_name,\n                              encoding=get_key_from_dict(self.file_conf, 'encoding', 'utf-8'),\n                              mode=get_key_from_dict(self.file_conf, 'mode', 'a')) as log_file:\n                        log_file.writelines(self.log_cache.cache.copy())\n                    self.log_cache.clear()\n                    if thread:\n                        self.running = False\n\n    def write_logs(self, string: str, flush: bool = False) -> None:\n        self.log_cache.append(string)\n        if len(self.log_cache.cache) >= 10:\n            self._log_file_time_write()\n            return None\n        if flush:\n            self._log_file_time_write()\n        if self.started and not self.running:\n            self.threaded_write = threading.Timer(1, self._log_file_time_write, kwargs={'thread': True})  # 基于 timer 的多线程\n            self.threaded_write.start()\n            self.running = True\n\n\nclass Logger:\n    \"\"\"shenjack logger\"\"\"\n\n    def __init__(self,\n                 name: str = 'root',\n                 level: int = DEBUG,\n                 file_conf: List[LogFileCache] = None,\n                 colors: Dict[Union[int, str], Dict[str, str]] = None,\n                 formats=None) -> None:\n        \"\"\"\n        配置模式: 使用 kwargs 配置\n        @param name: logger 名称 默认为 root\n        @param level: logging 输出等级 默认为 DEBUG(10)\n        @param file_conf: logger 的文件处理配置\n        @param colors: dict 颜色配置\n        @param formats: 格式化配置\n        \"\"\"\n        self.name = name\n        self.level = level\n        self.colors = colors or logger_configs['Color']['main_color']\n        self.formats = formats or logger_configs['Formatter'].copy()\n        self.min_level = self.level\n        if file_conf:\n            self.file_cache = file_conf\n            self.min_level = min(*[file.level for file in file_conf], self.level)\n        else:\n            self.file_cache = []\n        self.warn = self.warning\n\n    def add_file(self, handler: LogFileCache):\n        self.file_cache.append(handler)\n        self.min_level = min(*[file.level for file in self.file_cache], self.level)\n\n    def remove_file(self, handler: LogFileCache):\n        self.file_cache.pop(self.file_cache.index(handler))\n        self.min_level = min(*[file.level for file in self.file_cache], self.level)\n\n    def make_log(self, *values: object,\n                 level: int,\n                 sep: Optional[str] = ' ',\n                 end: Optional[str] = '\\n',\n                 flush: Optional[bool] = False,\n                 frame: Optional[FrameType] = None) -> None:\n        if level < self.min_level:\n            return None\n        if frame is None:\n            if (frame := inspect.currentframe()) is not None:\n                frame = frame if frame.f_back is None else frame.f_back if frame.f_back.f_back is None else frame.f_back.f_back\n        # text = sep.join(i if type(i) is str else str(i) for i in values)\n        text = f\"{self.colors[level]['message']}{sep.join(i if type(i) is str else str(i) for i in values)}{color_reset_suffix}\"\n        print_text = self.format_text(level=level, text=text, frame=frame)\n        if level >= self.level:\n            print(print_text, end=end)\n        for file in self.file_cache:\n            file: LogFileCache\n            if level < file.level:\n                continue\n            file.write_logs(f\"{re.sub(re_find_color_code, '', print_text)}{end}\", flush=flush)\n        return None\n\n    def format_text(self, level: int, text: str, frame: Optional[FrameType]) -> str:\n        level_with_color = f\"[{get_key_from_dict(self.colors[level], 'info')}{level_name_map[level]}{color_reset_suffix}]\"\n        level_with_color = f\"{level_with_color}{' ' * (9 - len_without_color_maker(level_with_color))}\"\n        formats = self.formats.copy()\n        if frame is not None:\n            formats['file_name'] = f\"{get_key_from_dict(self.colors[level], 'file_name', self.colors['file_name'])}{os.path.split(frame.f_code.co_filename)[-1]}{color_reset_suffix}\"\n            formats['code_line'] = f\"{get_key_from_dict(self.colors[level], 'code_line', self.colors['code_line'])}{frame.f_lineno}{color_reset_suffix}\"\n        formats['logger_name'] = f'{get_key_from_dict(self.colors[level], \"logger\", self.colors[\"logger\"])}{self.name}{color_reset_suffix}'\n        now_time = str(time.time())\n        for key, value in formats.items():\n            if isinstance(value, dict):\n                if 'strftime' in value:\n                    value['strftime']: str\n                    formats[key] = f\"{get_key_from_dict(self.colors[level], key, self.colors[key])}{strftime(value['strftime'].replace('%%S', now_time[now_time.find('.') + 1:now_time.find('.') + 4]))}{color_reset_suffix}\"\n        print_text = self.formats['MESSAGE']['format'].format(level_with_color=level_with_color,\n                                                              level=level_with_color, message=text,\n                                                              **formats)\n        return print_text\n\n    def trace(self, *values: object,\n              sep: Optional[str] = ' ',\n              end: Optional[str] = '\\n',\n              flush: Optional[bool] = False,\n              frame: Optional[FrameType] = None) -> None:\n        return self.make_log(*values, level=TRACE, sep=sep, end=end, flush=flush, frame=frame)\n\n    def fine(self, *values: object,\n             sep: Optional[str] = ' ',\n             end: Optional[str] = '\\n',\n             flush: Optional[bool] = False,\n             frame: Optional[FrameType] = None) -> None:\n        return self.make_log(*values, level=FINE, sep=sep, end=end, flush=flush, frame=frame)\n\n    def debug(self,\n              *values: object,\n              sep: Optional[str] = ' ',\n              end: Optional[str] = '\\n',\n              flush: Optional[bool] = False,\n              frame: Optional[FrameType] = None) -> None:\n        return self.make_log(*values, level=DEBUG, sep=sep, end=end, flush=flush, frame=frame)\n\n    def info(self,\n             *values: object,\n             sep: Optional[str] = ' ',\n             end: Optional[str] = '\\n',\n             flush: Optional[bool] = False,\n             frame: Optional[FrameType] = None) -> None:\n        return self.make_log(*values, level=INFO, sep=sep, end=end, flush=flush, frame=frame)\n\n    def warning(self,\n                *values: object,\n                sep: Optional[str] = ' ',\n                end: Optional[str] = '\\n',\n                flush: Optional[bool] = False,\n                frame: Optional[FrameType] = None) -> None:\n        return self.make_log(*values, level=WARNING, sep=sep, end=end, flush=flush, frame=frame)\n\n    def error(self,\n              *values: object,\n              sep: Optional[str] = ' ',\n              end: Optional[str] = '\\n',\n              flush: Optional[bool] = False,\n              frame: Optional[FrameType] = None) -> None:\n        return self.make_log(*values, level=ERROR, sep=sep, end=end, flush=flush, frame=frame)\n\n    def fatal(self,\n              *values: object,\n              sep: Optional[str] = ' ',\n              end: Optional[str] = '\\n',\n              flush: Optional[bool] = False,\n              frame: Optional[FrameType] = None) -> None:\n        return self.make_log(*values, level=FATAL, sep=sep, end=end, flush=flush, frame=frame)\n\n\ndef get_key_from_dict(a_dict: Dict, key: Any, default: Any = None) -> Optional[Any]:\n    if default is None:\n        return a_dict[key]\n    try:\n        return a_dict[key]\n    except KeyError:\n        return default\n\n\ndef format_str(text: str) -> str:\n    formats = logger_configs['Formatter'].copy()\n    now_time = str(time.time())\n    for key, value in formats.items():\n        if isinstance(value, dict):\n            if 'strftime' in value:\n                value['strftime']: str\n                formats[key] = strftime(value['strftime'].replace('%%S', now_time[now_time.find('.') + 1:now_time.find('.') + 4]))\n    return text.format(**formats)\n\n\ndef len_without_color_maker(text: str) -> int:\n    with_out_text = re.sub(re_find_color_code, '', text)\n    return len(with_out_text)\n\n\ndef gen_file_conf(file_name: str,\n                  file_level: int = DEBUG,\n                  file_mode: str = 'a',\n                  file_encoding: str = 'utf-8',\n                  file_cache_len: int = 10,\n                  file_cache_time: Union[int, float] = 1) -> dict:\n    \"\"\"\n    生成一个文件配置\n    @param file_name: 日志文件名\n    @param file_level: 日志文件记录级别\n    @param file_mode: 文件模式\n    @param file_encoding: 文件编码\n    @param file_cache_len: 文件缓存长度\n    @param file_cache_time: 文件缓存时间\n    @return: 生成的配置\n    \"\"\"\n    return {'file_name':  file_name,\n            'level':      file_level,\n            'mode':       file_mode,\n            'encoding':   file_encoding,\n            'cache_len':  file_cache_len,\n            'cache_time': file_cache_time}\n\n\ndef gen_color_conf(color_name: str = None, **colors) -> dict:\n    default_color = logger_configs['Color']['main_color' if color_name is None else color_name].copy()\n    default_color.update(colors)\n    return default_color\n\n\ndef logger_with_default_settings(name: str,\n                                 level: int = DEBUG,\n                                 file_conf: dict = None,\n                                 colors: dict = None,\n                                 formats: dict = None) -> Logger:\n    return Logger(name=name,\n                  level=level,\n                  file_conf=[LogFileCache(gen_file_conf(**file_conf))],\n                  colors=gen_color_conf(**colors),\n                  formats=logger_configs['Formatter'].copy().update(formats))\n\n\ndef add_file_config(conf_name: str,\n                    file_name: str,\n                    file_level: int = DEBUG,\n                    file_mode: str = 'a',\n                    file_encoding: str = 'utf-8',\n                    file_cache_len: int = 10,\n                    file_cache_time: Union[int, float] = 1) -> None:\n    \"\"\"\n    向 logger config 里添加一个文件配置\n    @param conf_name: 文件配置名称\n    @param file_name: 日志文件名\n    @param file_level: 日志文件记录级别\n    @param file_mode: 文件模式\n    @param file_encoding: 文件编码\n    @param file_cache_len: 文件缓存长度\n    @param file_cache_time: 文件缓存时间\n    @return: None\n    \"\"\"\n    logger_configs['File'][conf_name] = {'file_name':  file_name,\n                                         'level':      file_level,\n                                         'mode':       file_mode,\n                                         'encoding':   file_encoding,\n                                         'cache_len':  file_cache_len,\n                                         'cache_time': file_cache_time}\n\n\ndef add_dict_config_to_global(some_dict: Union[dict, list, str], name: str) -> dict:\n    \"\"\"\n    提前声明，这个函数很有可能搞坏 config\n    请使用 add_kwargs_to_global 来修改配置\n    如果你不知道你在改什么，请**务必不要**用这个函数来修改配置\n    @param some_dict: 一个你丢进来的 logger 设置\n    @param name: 这个 logger 设置的名称\n    @return: 修改过的 logger 配置\n    \"\"\"\n    logger_configs[name] = some_dict\n    return logger_configs  # 修改过的 logger 配置\n\n\ndef get_logger(name: str = 'root') -> Logger:\n    \"\"\"\n    此函数用于从 global_config 中取出对应的配置建立一个相应的 logger\n    @param name: logger的名称\n    @return: 创建好的 logger\n    \"\"\"\n    if name in logger_configs['Logger']:\n        the_config = logger_configs['Logger'][name]\n    else:\n        the_config = logger_configs['Logger']['root']\n    file_handler = None\n    if 'file' in the_config:\n        file_handler = [LogFileCache(logger_configs['File'][the_config['file']])]\n    return Logger(name=name,\n                  level=the_config['level'],\n                  file_conf=file_handler,\n                  colors=logger_configs['Color'][get_key_from_dict(the_config, 'color', 'main_color')],\n                  formats=logger_configs['Formatter'].copy())\n\n\ndef test_logger(the_logger: Logger):\n    the_logger.trace('tracing')\n    the_logger.fine('some fine!')\n    the_logger.debug('debugging')\n    the_logger.info(\"Hello World!!\")\n    the_logger.warn('warning')\n    the_logger.error('error haaaa')\n    the_logger.fatal('oh no')\n\n\nif __name__ == \"__main__\":\n    os.chdir('../../')\n    logger = get_logger('server')\n\n    logger.info('my name is:', logger.name)\n    a_logger = get_logger('client')\n\n    a_logger.trace('tracing')\n    a_logger.fine('some fine!')\n    a_logger.debug('debugging')\n    a_logger.info(\"Hello World!!\")\n    a_logger.warn('warning')\n    a_logger.error('error haaaa')\n    a_logger.fatal('oh no')\n    logger.info('my name is:', logger.name)\n    for x in range(5):\n        test_logger(logger)\n        test_logger(a_logger)\n",598],"C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\re.py":["#\n# Secret Labs' Regular Expression Engine\n#\n# re-compatible interface for the sre matching engine\n#\n# Copyright (c) 1998-2001 by Secret Labs AB.  All rights reserved.\n#\n# This version of the SRE library can be redistributed under CNRI's\n# Python 1.6 license.  For any other use, please contact Secret Labs\n# AB (info@pythonware.com).\n#\n# Portions of this engine have been developed in cooperation with\n# CNRI.  Hewlett-Packard provided funding for 1.6 integration and\n# other compatibility work.\n#\n\nr\"\"\"Support for regular expressions (RE).\n\nThis module provides regular expression matching operations similar to\nthose found in Perl.  It supports both 8-bit and Unicode strings; both\nthe pattern and the strings being processed can contain null bytes and\ncharacters outside the US ASCII range.\n\nRegular expressions can contain both special and ordinary characters.\nMost ordinary characters, like \"A\", \"a\", or \"0\", are the simplest\nregular expressions; they simply match themselves.  You can\nconcatenate ordinary characters, so last matches the string 'last'.\n\nThe special characters are:\n    \".\"      Matches any character except a newline.\n    \"^\"      Matches the start of the string.\n    \"$\"      Matches the end of the string or just before the newline at\n             the end of the string.\n    \"*\"      Matches 0 or more (greedy) repetitions of the preceding RE.\n             Greedy means that it will match as many repetitions as possible.\n    \"+\"      Matches 1 or more (greedy) repetitions of the preceding RE.\n    \"?\"      Matches 0 or 1 (greedy) of the preceding RE.\n    *?,+?,?? Non-greedy versions of the previous three special characters.\n    {m,n}    Matches from m to n repetitions of the preceding RE.\n    {m,n}?   Non-greedy version of the above.\n    \"\\\\\"     Either escapes special characters or signals a special sequence.\n    []       Indicates a set of characters.\n             A \"^\" as the first character indicates a complementing set.\n    \"|\"      A|B, creates an RE that will match either A or B.\n    (...)    Matches the RE inside the parentheses.\n             The contents can be retrieved or matched later in the string.\n    (?aiLmsux) The letters set the corresponding flags defined below.\n    (?:...)  Non-grouping version of regular parentheses.\n    (?P<name>...) The substring matched by the group is accessible by name.\n    (?P=name)     Matches the text matched earlier by the group named name.\n    (?#...)  A comment; ignored.\n    (?=...)  Matches if ... matches next, but doesn't consume the string.\n    (?!...)  Matches if ... doesn't match next.\n    (?<=...) Matches if preceded by ... (must be fixed length).\n    (?<!...) Matches if not preceded by ... (must be fixed length).\n    (?(id/name)yes|no) Matches yes pattern if the group with id/name matched,\n                       the (optional) no pattern otherwise.\n\nThe special sequences consist of \"\\\\\" and a character from the list\nbelow.  If the ordinary character is not on the list, then the\nresulting RE will match the second character.\n    \\number  Matches the contents of the group of the same number.\n    \\A       Matches only at the start of the string.\n    \\Z       Matches only at the end of the string.\n    \\b       Matches the empty string, but only at the start or end of a word.\n    \\B       Matches the empty string, but not at the start or end of a word.\n    \\d       Matches any decimal digit; equivalent to the set [0-9] in\n             bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the whole\n             range of Unicode digits.\n    \\D       Matches any non-digit character; equivalent to [^\\d].\n    \\s       Matches any whitespace character; equivalent to [ \\t\\n\\r\\f\\v] in\n             bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the whole\n             range of Unicode whitespace characters.\n    \\S       Matches any non-whitespace character; equivalent to [^\\s].\n    \\w       Matches any alphanumeric character; equivalent to [a-zA-Z0-9_]\n             in bytes patterns or string patterns with the ASCII flag.\n             In string patterns without the ASCII flag, it will match the\n             range of Unicode alphanumeric characters (letters plus digits\n             plus underscore).\n             With LOCALE, it will match the set [0-9_] plus characters defined\n             as letters for the current locale.\n    \\W       Matches the complement of \\w.\n    \\\\       Matches a literal backslash.\n\nThis module exports the following functions:\n    match     Match a regular expression pattern to the beginning of a string.\n    fullmatch Match a regular expression pattern to all of a string.\n    search    Search a string for the presence of a pattern.\n    sub       Substitute occurrences of a pattern found in a string.\n    subn      Same as sub, but also return the number of substitutions made.\n    split     Split a string by the occurrences of a pattern.\n    findall   Find all occurrences of a pattern in a string.\n    finditer  Return an iterator yielding a Match object for each match.\n    compile   Compile a pattern into a Pattern object.\n    purge     Clear the regular expression cache.\n    escape    Backslash all non-alphanumerics in a string.\n\nEach function other than purge and escape can take an optional 'flags' argument\nconsisting of one or more of the following module constants, joined by \"|\".\nA, L, and U are mutually exclusive.\n    A  ASCII       For string patterns, make \\w, \\W, \\b, \\B, \\d, \\D\n                   match the corresponding ASCII character categories\n                   (rather than the whole Unicode categories, which is the\n                   default).\n                   For bytes patterns, this flag is the only available\n                   behaviour and needn't be specified.\n    I  IGNORECASE  Perform case-insensitive matching.\n    L  LOCALE      Make \\w, \\W, \\b, \\B, dependent on the current locale.\n    M  MULTILINE   \"^\" matches the beginning of lines (after a newline)\n                   as well as the string.\n                   \"$\" matches the end of lines (before a newline) as well\n                   as the end of the string.\n    S  DOTALL      \".\" matches any character at all, including the newline.\n    X  VERBOSE     Ignore whitespace and comments for nicer looking RE's.\n    U  UNICODE     For compatibility only. Ignored for string patterns (it\n                   is the default), and forbidden for bytes patterns.\n\nThis module also defines an exception 'error'.\n\n\"\"\"\n\nimport enum\nimport sre_compile\nimport sre_parse\nimport functools\ntry:\n    import _locale\nexcept ImportError:\n    _locale = None\n\n\n# public symbols\n__all__ = [\n    \"match\", \"fullmatch\", \"search\", \"sub\", \"subn\", \"split\",\n    \"findall\", \"finditer\", \"compile\", \"purge\", \"template\", \"escape\",\n    \"error\", \"Pattern\", \"Match\", \"A\", \"I\", \"L\", \"M\", \"S\", \"X\", \"U\",\n    \"ASCII\", \"IGNORECASE\", \"LOCALE\", \"MULTILINE\", \"DOTALL\", \"VERBOSE\",\n    \"UNICODE\",\n]\n\n__version__ = \"2.2.1\"\n\nclass RegexFlag(enum.IntFlag):\n    ASCII = A = sre_compile.SRE_FLAG_ASCII # assume ascii \"locale\"\n    IGNORECASE = I = sre_compile.SRE_FLAG_IGNORECASE # ignore case\n    LOCALE = L = sre_compile.SRE_FLAG_LOCALE # assume current 8-bit locale\n    UNICODE = U = sre_compile.SRE_FLAG_UNICODE # assume unicode \"locale\"\n    MULTILINE = M = sre_compile.SRE_FLAG_MULTILINE # make anchors look for newline\n    DOTALL = S = sre_compile.SRE_FLAG_DOTALL # make dot match newline\n    VERBOSE = X = sre_compile.SRE_FLAG_VERBOSE # ignore whitespace and comments\n    # sre extensions (experimental, don't rely on these)\n    TEMPLATE = T = sre_compile.SRE_FLAG_TEMPLATE # disable backtracking\n    DEBUG = sre_compile.SRE_FLAG_DEBUG # dump pattern after compilation\n\n    def __repr__(self):\n        if self._name_ is not None:\n            return f're.{self._name_}'\n        value = self._value_\n        members = []\n        negative = value < 0\n        if negative:\n            value = ~value\n        for m in self.__class__:\n            if value & m._value_:\n                value &= ~m._value_\n                members.append(f're.{m._name_}')\n        if value:\n            members.append(hex(value))\n        res = '|'.join(members)\n        if negative:\n            if len(members) > 1:\n                res = f'~({res})'\n            else:\n                res = f'~{res}'\n        return res\n    __str__ = object.__str__\n\nglobals().update(RegexFlag.__members__)\n\n# sre exception\nerror = sre_compile.error\n\n# --------------------------------------------------------------------\n# public interface\n\ndef match(pattern, string, flags=0):\n    \"\"\"Try to apply the pattern at the start of the string, returning\n    a Match object, or None if no match was found.\"\"\"\n    return _compile(pattern, flags).match(string)\n\ndef fullmatch(pattern, string, flags=0):\n    \"\"\"Try to apply the pattern to all of the string, returning\n    a Match object, or None if no match was found.\"\"\"\n    return _compile(pattern, flags).fullmatch(string)\n\ndef search(pattern, string, flags=0):\n    \"\"\"Scan through string looking for a match to the pattern, returning\n    a Match object, or None if no match was found.\"\"\"\n    return _compile(pattern, flags).search(string)\n\ndef sub(pattern, repl, string, count=0, flags=0):\n    \"\"\"Return the string obtained by replacing the leftmost\n    non-overlapping occurrences of the pattern in string by the\n    replacement repl.  repl can be either a string or a callable;\n    if a string, backslash escapes in it are processed.  If it is\n    a callable, it's passed the Match object and must return\n    a replacement string to be used.\"\"\"\n    return _compile(pattern, flags).sub(repl, string, count)\n\ndef subn(pattern, repl, string, count=0, flags=0):\n    \"\"\"Return a 2-tuple containing (new_string, number).\n    new_string is the string obtained by replacing the leftmost\n    non-overlapping occurrences of the pattern in the source\n    string by the replacement repl.  number is the number of\n    substitutions that were made. repl can be either a string or a\n    callable; if a string, backslash escapes in it are processed.\n    If it is a callable, it's passed the Match object and must\n    return a replacement string to be used.\"\"\"\n    return _compile(pattern, flags).subn(repl, string, count)\n\ndef split(pattern, string, maxsplit=0, flags=0):\n    \"\"\"Split the source string by the occurrences of the pattern,\n    returning a list containing the resulting substrings.  If\n    capturing parentheses are used in pattern, then the text of all\n    groups in the pattern are also returned as part of the resulting\n    list.  If maxsplit is nonzero, at most maxsplit splits occur,\n    and the remainder of the string is returned as the final element\n    of the list.\"\"\"\n    return _compile(pattern, flags).split(string, maxsplit)\n\ndef findall(pattern, string, flags=0):\n    \"\"\"Return a list of all non-overlapping matches in the string.\n\n    If one or more capturing groups are present in the pattern, return\n    a list of groups; this will be a list of tuples if the pattern\n    has more than one group.\n\n    Empty matches are included in the result.\"\"\"\n    return _compile(pattern, flags).findall(string)\n\ndef finditer(pattern, string, flags=0):\n    \"\"\"Return an iterator over all non-overlapping matches in the\n    string.  For each match, the iterator returns a Match object.\n\n    Empty matches are included in the result.\"\"\"\n    return _compile(pattern, flags).finditer(string)\n\ndef compile(pattern, flags=0):\n    \"Compile a regular expression pattern, returning a Pattern object.\"\n    return _compile(pattern, flags)\n\ndef purge():\n    \"Clear the regular expression caches\"\n    _cache.clear()\n    _compile_repl.cache_clear()\n\ndef template(pattern, flags=0):\n    \"Compile a template pattern, returning a Pattern object\"\n    return _compile(pattern, flags|T)\n\n# SPECIAL_CHARS\n# closing ')', '}' and ']'\n# '-' (a range in character set)\n# '&', '~', (extended character set operations)\n# '#' (comment) and WHITESPACE (ignored) in verbose mode\n_special_chars_map = {i: '\\\\' + chr(i) for i in b'()[]{}?*+-|^$\\\\.&~# \\t\\n\\r\\v\\f'}\n\ndef escape(pattern):\n    \"\"\"\n    Escape special characters in a string.\n    \"\"\"\n    if isinstance(pattern, str):\n        return pattern.translate(_special_chars_map)\n    else:\n        pattern = str(pattern, 'latin1')\n        return pattern.translate(_special_chars_map).encode('latin1')\n\nPattern = type(sre_compile.compile('', 0))\nMatch = type(sre_compile.compile('', 0).match(''))\n\n# --------------------------------------------------------------------\n# internals\n\n_cache = {}  # ordered!\n\n_MAXCACHE = 512\ndef _compile(pattern, flags):\n    # internal: compile pattern\n    if isinstance(flags, RegexFlag):\n        flags = flags.value\n    try:\n        return _cache[type(pattern), pattern, flags]\n    except KeyError:\n        pass\n    if isinstance(pattern, Pattern):\n        if flags:\n            raise ValueError(\n                \"cannot process flags argument with a compiled pattern\")\n        return pattern\n    if not sre_compile.isstring(pattern):\n        raise TypeError(\"first argument must be string or compiled pattern\")\n    p = sre_compile.compile(pattern, flags)\n    if not (flags & DEBUG):\n        if len(_cache) >= _MAXCACHE:\n            # Drop the oldest item\n            try:\n                del _cache[next(iter(_cache))]\n            except (StopIteration, RuntimeError, KeyError):\n                pass\n        _cache[type(pattern), pattern, flags] = p\n    return p\n\n@functools.lru_cache(_MAXCACHE)\ndef _compile_repl(repl, pattern):\n    # internal: compile replacement pattern\n    return sre_parse.parse_template(repl, pattern)\n\ndef _expand(pattern, match, template):\n    # internal: Match.expand implementation hook\n    template = sre_parse.parse_template(template, pattern)\n    return sre_parse.expand_template(template, match)\n\ndef _subx(pattern, template):\n    # internal: Pattern.sub/subn implementation helper\n    template = _compile_repl(template, pattern)\n    if not template[0] and len(template[1]) == 1:\n        # literal replacement\n        return template[1][0]\n    def filter(match, template=template):\n        return sre_parse.expand_template(template, match)\n    return filter\n\n# register myself for pickling\n\nimport copyreg\n\ndef _pickle(p):\n    return _compile, (p.pattern, p.flags)\n\ncopyreg.pickle(Pattern, _pickle, _compile)\n\n# --------------------------------------------------------------------\n# experimental stuff (see python-dev discussions for details)\n\nclass Scanner:\n    def __init__(self, lexicon, flags=0):\n        from sre_constants import BRANCH, SUBPATTERN\n        if isinstance(flags, RegexFlag):\n            flags = flags.value\n        self.lexicon = lexicon\n        # combine phrases into a compound pattern\n        p = []\n        s = sre_parse.State()\n        s.flags = flags\n        for phrase, action in lexicon:\n            gid = s.opengroup()\n            p.append(sre_parse.SubPattern(s, [\n                (SUBPATTERN, (gid, 0, 0, sre_parse.parse(phrase, flags))),\n                ]))\n            s.closegroup(gid, p[-1])\n        p = sre_parse.SubPattern(s, [(BRANCH, (None, p))])\n        self.scanner = sre_compile.compile(p)\n    def scan(self, string):\n        result = []\n        append = result.append\n        match = self.scanner.scanner(string).match\n        i = 0\n        while True:\n            m = match()\n            if not m:\n                break\n            j = m.end()\n            if i == j:\n                break\n            action = self.lexicon[m.lastindex-1][1]\n            if callable(action):\n                self.match = m\n                action = action(self, m.group())\n            if action is not None:\n                append(action)\n            i = j\n        return result, string[i:]\n",384],"C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py":["# Module 'ntpath' -- common operations on WinNT/Win95 pathnames\n\"\"\"Common pathname manipulations, WindowsNT/95 version.\n\nInstead of importing this module directly, import os and refer to this\nmodule as os.path.\n\"\"\"\n\n# strings representing various path-related bits and pieces\n# These are primarily for export; internally, they are hardcoded.\n# Should be set before imports for resolving cyclic dependency.\ncurdir = '.'\npardir = '..'\nextsep = '.'\nsep = '\\\\'\npathsep = ';'\naltsep = '/'\ndefpath = '.;C:\\\\bin'\ndevnull = 'nul'\n\nimport os\nimport sys\nimport stat\nimport genericpath\nfrom genericpath import *\n\n__all__ = [\"normcase\",\"isabs\",\"join\",\"splitdrive\",\"split\",\"splitext\",\n           \"basename\",\"dirname\",\"commonprefix\",\"getsize\",\"getmtime\",\n           \"getatime\",\"getctime\", \"islink\",\"exists\",\"lexists\",\"isdir\",\"isfile\",\n           \"ismount\", \"expanduser\",\"expandvars\",\"normpath\",\"abspath\",\n           \"curdir\",\"pardir\",\"sep\",\"pathsep\",\"defpath\",\"altsep\",\n           \"extsep\",\"devnull\",\"realpath\",\"supports_unicode_filenames\",\"relpath\",\n           \"samefile\", \"sameopenfile\", \"samestat\", \"commonpath\"]\n\ndef _get_bothseps(path):\n    if isinstance(path, bytes):\n        return b'\\\\/'\n    else:\n        return '\\\\/'\n\n# Normalize the case of a pathname and map slashes to backslashes.\n# Other normalizations (such as optimizing '../' away) are not done\n# (this is done by normpath).\n\ndef normcase(s):\n    \"\"\"Normalize case of pathname.\n\n    Makes all characters lowercase and all slashes into backslashes.\"\"\"\n    s = os.fspath(s)\n    if isinstance(s, bytes):\n        return s.replace(b'/', b'\\\\').lower()\n    else:\n        return s.replace('/', '\\\\').lower()\n\n\n# Return whether a path is absolute.\n# Trivial in Posix, harder on Windows.\n# For Windows it is absolute if it starts with a slash or backslash (current\n# volume), or if a pathname after the volume-letter-and-colon or UNC-resource\n# starts with a slash or backslash.\n\ndef isabs(s):\n    \"\"\"Test whether a path is absolute\"\"\"\n    s = os.fspath(s)\n    # Paths beginning with \\\\?\\ are always absolute, but do not\n    # necessarily contain a drive.\n    if isinstance(s, bytes):\n        if s.replace(b'/', b'\\\\').startswith(b'\\\\\\\\?\\\\'):\n            return True\n    else:\n        if s.replace('/', '\\\\').startswith('\\\\\\\\?\\\\'):\n            return True\n    s = splitdrive(s)[1]\n    return len(s) > 0 and s[0] in _get_bothseps(s)\n\n\n# Join two (or more) paths.\ndef join(path, *paths):\n    path = os.fspath(path)\n    if isinstance(path, bytes):\n        sep = b'\\\\'\n        seps = b'\\\\/'\n        colon = b':'\n    else:\n        sep = '\\\\'\n        seps = '\\\\/'\n        colon = ':'\n    try:\n        if not paths:\n            path[:0] + sep  #23780: Ensure compatible data type even if p is null.\n        result_drive, result_path = splitdrive(path)\n        for p in map(os.fspath, paths):\n            p_drive, p_path = splitdrive(p)\n            if p_path and p_path[0] in seps:\n                # Second path is absolute\n                if p_drive or not result_drive:\n                    result_drive = p_drive\n                result_path = p_path\n                continue\n            elif p_drive and p_drive != result_drive:\n                if p_drive.lower() != result_drive.lower():\n                    # Different drives => ignore the first path entirely\n                    result_drive = p_drive\n                    result_path = p_path\n                    continue\n                # Same drive in different case\n                result_drive = p_drive\n            # Second path is relative to the first\n            if result_path and result_path[-1] not in seps:\n                result_path = result_path + sep\n            result_path = result_path + p_path\n        ## add separator between UNC and non-absolute path\n        if (result_path and result_path[0] not in seps and\n            result_drive and result_drive[-1:] != colon):\n            return result_drive + sep + result_path\n        return result_drive + result_path\n    except (TypeError, AttributeError, BytesWarning):\n        genericpath._check_arg_types('join', path, *paths)\n        raise\n\n\n# Split a path in a drive specification (a drive letter followed by a\n# colon) and the path specification.\n# It is always true that drivespec + pathspec == p\ndef splitdrive(p):\n    \"\"\"Split a pathname into drive/UNC sharepoint and relative path specifiers.\n    Returns a 2-tuple (drive_or_unc, path); either part may be empty.\n\n    If you assign\n        result = splitdrive(p)\n    It is always true that:\n        result[0] + result[1] == p\n\n    If the path contained a drive letter, drive_or_unc will contain everything\n    up to and including the colon.  e.g. splitdrive(\"c:/dir\") returns (\"c:\", \"/dir\")\n\n    If the path contained a UNC path, the drive_or_unc will contain the host name\n    and share up to but not including the fourth directory separator character.\n    e.g. splitdrive(\"//host/computer/dir\") returns (\"//host/computer\", \"/dir\")\n\n    Paths cannot contain both a drive letter and a UNC path.\n\n    \"\"\"\n    p = os.fspath(p)\n    if len(p) >= 2:\n        if isinstance(p, bytes):\n            sep = b'\\\\'\n            altsep = b'/'\n            colon = b':'\n        else:\n            sep = '\\\\'\n            altsep = '/'\n            colon = ':'\n        normp = p.replace(altsep, sep)\n        if (normp[0:2] == sep*2) and (normp[2:3] != sep):\n            # is a UNC path:\n            # vvvvvvvvvvvvvvvvvvvv drive letter or UNC path\n            # \\\\machine\\mountpoint\\directory\\etc\\...\n            #           directory ^^^^^^^^^^^^^^^\n            index = normp.find(sep, 2)\n            if index == -1:\n                return p[:0], p\n            index2 = normp.find(sep, index + 1)\n            # a UNC path can't have two slashes in a row\n            # (after the initial two)\n            if index2 == index + 1:\n                return p[:0], p\n            if index2 == -1:\n                index2 = len(p)\n            return p[:index2], p[index2:]\n        if normp[1:2] == colon:\n            return p[:2], p[2:]\n    return p[:0], p\n\n\n# Split a path in head (everything up to the last '/') and tail (the\n# rest).  After the trailing '/' is stripped, the invariant\n# join(head, tail) == p holds.\n# The resulting head won't end in '/' unless it is the root.\n\ndef split(p):\n    \"\"\"Split a pathname.\n\n    Return tuple (head, tail) where tail is everything after the final slash.\n    Either part may be empty.\"\"\"\n    p = os.fspath(p)\n    seps = _get_bothseps(p)\n    d, p = splitdrive(p)\n    # set i to index beyond p's last slash\n    i = len(p)\n    while i and p[i-1] not in seps:\n        i -= 1\n    head, tail = p[:i], p[i:]  # now tail has no slashes\n    # remove trailing slashes from head, unless it's all slashes\n    head = head.rstrip(seps) or head\n    return d + head, tail\n\n\n# Split a path in root and extension.\n# The extension is everything starting at the last dot in the last\n# pathname component; the root is everything before that.\n# It is always true that root + ext == p.\n\ndef splitext(p):\n    p = os.fspath(p)\n    if isinstance(p, bytes):\n        return genericpath._splitext(p, b'\\\\', b'/', b'.')\n    else:\n        return genericpath._splitext(p, '\\\\', '/', '.')\nsplitext.__doc__ = genericpath._splitext.__doc__\n\n\n# Return the tail (basename) part of a path.\n\ndef basename(p):\n    \"\"\"Returns the final component of a pathname\"\"\"\n    return split(p)[1]\n\n\n# Return the head (dirname) part of a path.\n\ndef dirname(p):\n    \"\"\"Returns the directory component of a pathname\"\"\"\n    return split(p)[0]\n\n# Is a path a symbolic link?\n# This will always return false on systems where os.lstat doesn't exist.\n\ndef islink(path):\n    \"\"\"Test whether a path is a symbolic link.\n    This will always return false for Windows prior to 6.0.\n    \"\"\"\n    try:\n        st = os.lstat(path)\n    except (OSError, ValueError, AttributeError):\n        return False\n    return stat.S_ISLNK(st.st_mode)\n\n# Being true for dangling symbolic links is also useful.\n\ndef lexists(path):\n    \"\"\"Test whether a path exists.  Returns True for broken symbolic links\"\"\"\n    try:\n        st = os.lstat(path)\n    except (OSError, ValueError):\n        return False\n    return True\n\n# Is a path a mount point?\n# Any drive letter root (eg c:\\)\n# Any share UNC (eg \\\\server\\share)\n# Any volume mounted on a filesystem folder\n#\n# No one method detects all three situations. Historically we've lexically\n# detected drive letter roots and share UNCs. The canonical approach to\n# detecting mounted volumes (querying the reparse tag) fails for the most\n# common case: drive letter roots. The alternative which uses GetVolumePathName\n# fails if the drive letter is the result of a SUBST.\ntry:\n    from nt import _getvolumepathname\nexcept ImportError:\n    _getvolumepathname = None\ndef ismount(path):\n    \"\"\"Test whether a path is a mount point (a drive root, the root of a\n    share, or a mounted volume)\"\"\"\n    path = os.fspath(path)\n    seps = _get_bothseps(path)\n    path = abspath(path)\n    root, rest = splitdrive(path)\n    if root and root[0] in seps:\n        return (not rest) or (rest in seps)\n    if rest in seps:\n        return True\n\n    if _getvolumepathname:\n        return path.rstrip(seps) == _getvolumepathname(path).rstrip(seps)\n    else:\n        return False\n\n\n# Expand paths beginning with '~' or '~user'.\n# '~' means $HOME; '~user' means that user's home directory.\n# If the path doesn't begin with '~', or if the user or $HOME is unknown,\n# the path is returned unchanged (leaving error reporting to whatever\n# function is called with the expanded path as argument).\n# See also module 'glob' for expansion of *, ? and [...] in pathnames.\n# (A function should also be defined to do full *sh-style environment\n# variable expansion.)\n\ndef expanduser(path):\n    \"\"\"Expand ~ and ~user constructs.\n\n    If user or $HOME is unknown, do nothing.\"\"\"\n    path = os.fspath(path)\n    if isinstance(path, bytes):\n        tilde = b'~'\n    else:\n        tilde = '~'\n    if not path.startswith(tilde):\n        return path\n    i, n = 1, len(path)\n    while i < n and path[i] not in _get_bothseps(path):\n        i += 1\n\n    if 'USERPROFILE' in os.environ:\n        userhome = os.environ['USERPROFILE']\n    elif not 'HOMEPATH' in os.environ:\n        return path\n    else:\n        try:\n            drive = os.environ['HOMEDRIVE']\n        except KeyError:\n            drive = ''\n        userhome = join(drive, os.environ['HOMEPATH'])\n\n    if isinstance(path, bytes):\n        userhome = os.fsencode(userhome)\n\n    if i != 1: #~user\n        userhome = join(dirname(userhome), path[1:i])\n\n    return userhome + path[i:]\n\n\n# Expand paths containing shell variable substitutions.\n# The following rules apply:\n#       - no expansion within single quotes\n#       - '$$' is translated into '$'\n#       - '%%' is translated into '%' if '%%' are not seen in %var1%%var2%\n#       - ${varname} is accepted.\n#       - $varname is accepted.\n#       - %varname% is accepted.\n#       - varnames can be made out of letters, digits and the characters '_-'\n#         (though is not verified in the ${varname} and %varname% cases)\n# XXX With COMMAND.COM you can use any characters in a variable name,\n# XXX except '^|<>='.\n\ndef expandvars(path):\n    \"\"\"Expand shell variables of the forms $var, ${var} and %var%.\n\n    Unknown variables are left unchanged.\"\"\"\n    path = os.fspath(path)\n    if isinstance(path, bytes):\n        if b'$' not in path and b'%' not in path:\n            return path\n        import string\n        varchars = bytes(string.ascii_letters + string.digits + '_-', 'ascii')\n        quote = b'\\''\n        percent = b'%'\n        brace = b'{'\n        rbrace = b'}'\n        dollar = b'$'\n        environ = getattr(os, 'environb', None)\n    else:\n        if '$' not in path and '%' not in path:\n            return path\n        import string\n        varchars = string.ascii_letters + string.digits + '_-'\n        quote = '\\''\n        percent = '%'\n        brace = '{'\n        rbrace = '}'\n        dollar = '$'\n        environ = os.environ\n    res = path[:0]\n    index = 0\n    pathlen = len(path)\n    while index < pathlen:\n        c = path[index:index+1]\n        if c == quote:   # no expansion within single quotes\n            path = path[index + 1:]\n            pathlen = len(path)\n            try:\n                index = path.index(c)\n                res += c + path[:index + 1]\n            except ValueError:\n                res += c + path\n                index = pathlen - 1\n        elif c == percent:  # variable or '%'\n            if path[index + 1:index + 2] == percent:\n                res += c\n                index += 1\n            else:\n                path = path[index+1:]\n                pathlen = len(path)\n                try:\n                    index = path.index(percent)\n                except ValueError:\n                    res += percent + path\n                    index = pathlen - 1\n                else:\n                    var = path[:index]\n                    try:\n                        if environ is None:\n                            value = os.fsencode(os.environ[os.fsdecode(var)])\n                        else:\n                            value = environ[var]\n                    except KeyError:\n                        value = percent + var + percent\n                    res += value\n        elif c == dollar:  # variable or '$$'\n            if path[index + 1:index + 2] == dollar:\n                res += c\n                index += 1\n            elif path[index + 1:index + 2] == brace:\n                path = path[index+2:]\n                pathlen = len(path)\n                try:\n                    index = path.index(rbrace)\n                except ValueError:\n                    res += dollar + brace + path\n                    index = pathlen - 1\n                else:\n                    var = path[:index]\n                    try:\n                        if environ is None:\n                            value = os.fsencode(os.environ[os.fsdecode(var)])\n                        else:\n                            value = environ[var]\n                    except KeyError:\n                        value = dollar + brace + var + rbrace\n                    res += value\n            else:\n                var = path[:0]\n                index += 1\n                c = path[index:index + 1]\n                while c and c in varchars:\n                    var += c\n                    index += 1\n                    c = path[index:index + 1]\n                try:\n                    if environ is None:\n                        value = os.fsencode(os.environ[os.fsdecode(var)])\n                    else:\n                        value = environ[var]\n                except KeyError:\n                    value = dollar + var\n                res += value\n                if c:\n                    index -= 1\n        else:\n            res += c\n        index += 1\n    return res\n\n\n# Normalize a path, e.g. A//B, A/./B and A/foo/../B all become A\\B.\n# Previously, this function also truncated pathnames to 8+3 format,\n# but as this module is called \"ntpath\", that's obviously wrong!\n\ndef normpath(path):\n    \"\"\"Normalize path, eliminating double slashes, etc.\"\"\"\n    path = os.fspath(path)\n    if isinstance(path, bytes):\n        sep = b'\\\\'\n        altsep = b'/'\n        curdir = b'.'\n        pardir = b'..'\n        special_prefixes = (b'\\\\\\\\.\\\\', b'\\\\\\\\?\\\\')\n    else:\n        sep = '\\\\'\n        altsep = '/'\n        curdir = '.'\n        pardir = '..'\n        special_prefixes = ('\\\\\\\\.\\\\', '\\\\\\\\?\\\\')\n    if path.startswith(special_prefixes):\n        # in the case of paths with these prefixes:\n        # \\\\.\\ -> device names\n        # \\\\?\\ -> literal paths\n        # do not do any normalization, but return the path\n        # unchanged apart from the call to os.fspath()\n        return path\n    path = path.replace(altsep, sep)\n    prefix, path = splitdrive(path)\n\n    # collapse initial backslashes\n    if path.startswith(sep):\n        prefix += sep\n        path = path.lstrip(sep)\n\n    comps = path.split(sep)\n    i = 0\n    while i < len(comps):\n        if not comps[i] or comps[i] == curdir:\n            del comps[i]\n        elif comps[i] == pardir:\n            if i > 0 and comps[i-1] != pardir:\n                del comps[i-1:i+1]\n                i -= 1\n            elif i == 0 and prefix.endswith(sep):\n                del comps[i]\n            else:\n                i += 1\n        else:\n            i += 1\n    # If the path is now empty, substitute '.'\n    if not prefix and not comps:\n        comps.append(curdir)\n    return prefix + sep.join(comps)\n\ndef _abspath_fallback(path):\n    \"\"\"Return the absolute version of a path as a fallback function in case\n    `nt._getfullpathname` is not available or raises OSError. See bpo-31047 for\n    more.\n\n    \"\"\"\n\n    path = os.fspath(path)\n    if not isabs(path):\n        if isinstance(path, bytes):\n            cwd = os.getcwdb()\n        else:\n            cwd = os.getcwd()\n        path = join(cwd, path)\n    return normpath(path)\n\n# Return an absolute path.\ntry:\n    from nt import _getfullpathname\n\nexcept ImportError: # not running on Windows - mock up something sensible\n    abspath = _abspath_fallback\n\nelse:  # use native Windows method on Windows\n    def abspath(path):\n        \"\"\"Return the absolute version of a path.\"\"\"\n        try:\n            return normpath(_getfullpathname(path))\n        except (OSError, ValueError):\n            return _abspath_fallback(path)\n\ntry:\n    from nt import _getfinalpathname, readlink as _nt_readlink\nexcept ImportError:\n    # realpath is a no-op on systems without _getfinalpathname support.\n    realpath = abspath\nelse:\n    def _readlink_deep(path):\n        # These error codes indicate that we should stop reading links and\n        # return the path we currently have.\n        # 1: ERROR_INVALID_FUNCTION\n        # 2: ERROR_FILE_NOT_FOUND\n        # 3: ERROR_DIRECTORY_NOT_FOUND\n        # 5: ERROR_ACCESS_DENIED\n        # 21: ERROR_NOT_READY (implies drive with no media)\n        # 32: ERROR_SHARING_VIOLATION (probably an NTFS paging file)\n        # 50: ERROR_NOT_SUPPORTED (implies no support for reparse points)\n        # 67: ERROR_BAD_NET_NAME (implies remote server unavailable)\n        # 87: ERROR_INVALID_PARAMETER\n        # 4390: ERROR_NOT_A_REPARSE_POINT\n        # 4392: ERROR_INVALID_REPARSE_DATA\n        # 4393: ERROR_REPARSE_TAG_INVALID\n        allowed_winerror = 1, 2, 3, 5, 21, 32, 50, 67, 87, 4390, 4392, 4393\n\n        seen = set()\n        while normcase(path) not in seen:\n            seen.add(normcase(path))\n            try:\n                old_path = path\n                path = _nt_readlink(path)\n                # Links may be relative, so resolve them against their\n                # own location\n                if not isabs(path):\n                    # If it's something other than a symlink, we don't know\n                    # what it's actually going to be resolved against, so\n                    # just return the old path.\n                    if not islink(old_path):\n                        path = old_path\n                        break\n                    path = normpath(join(dirname(old_path), path))\n            except OSError as ex:\n                if ex.winerror in allowed_winerror:\n                    break\n                raise\n            except ValueError:\n                # Stop on reparse points that are not symlinks\n                break\n        return path\n\n    def _getfinalpathname_nonstrict(path):\n        # These error codes indicate that we should stop resolving the path\n        # and return the value we currently have.\n        # 1: ERROR_INVALID_FUNCTION\n        # 2: ERROR_FILE_NOT_FOUND\n        # 3: ERROR_DIRECTORY_NOT_FOUND\n        # 5: ERROR_ACCESS_DENIED\n        # 21: ERROR_NOT_READY (implies drive with no media)\n        # 32: ERROR_SHARING_VIOLATION (probably an NTFS paging file)\n        # 50: ERROR_NOT_SUPPORTED\n        # 67: ERROR_BAD_NET_NAME (implies remote server unavailable)\n        # 87: ERROR_INVALID_PARAMETER\n        # 123: ERROR_INVALID_NAME\n        # 1920: ERROR_CANT_ACCESS_FILE\n        # 1921: ERROR_CANT_RESOLVE_FILENAME (implies unfollowable symlink)\n        allowed_winerror = 1, 2, 3, 5, 21, 32, 50, 67, 87, 123, 1920, 1921\n\n        # Non-strict algorithm is to find as much of the target directory\n        # as we can and join the rest.\n        tail = ''\n        while path:\n            try:\n                path = _getfinalpathname(path)\n                return join(path, tail) if tail else path\n            except OSError as ex:\n                if ex.winerror not in allowed_winerror:\n                    raise\n                try:\n                    # The OS could not resolve this path fully, so we attempt\n                    # to follow the link ourselves. If we succeed, join the tail\n                    # and return.\n                    new_path = _readlink_deep(path)\n                    if new_path != path:\n                        return join(new_path, tail) if tail else new_path\n                except OSError:\n                    # If we fail to readlink(), let's keep traversing\n                    pass\n                path, name = split(path)\n                # TODO (bpo-38186): Request the real file name from the directory\n                # entry using FindFirstFileW. For now, we will return the path\n                # as best we have it\n                if path and not name:\n                    return path + tail\n                tail = join(name, tail) if tail else name\n        return tail\n\n    def realpath(path):\n        path = normpath(path)\n        if isinstance(path, bytes):\n            prefix = b'\\\\\\\\?\\\\'\n            unc_prefix = b'\\\\\\\\?\\\\UNC\\\\'\n            new_unc_prefix = b'\\\\\\\\'\n            cwd = os.getcwdb()\n            # bpo-38081: Special case for realpath(b'nul')\n            if normcase(path) == normcase(os.fsencode(devnull)):\n                return b'\\\\\\\\.\\\\NUL'\n        else:\n            prefix = '\\\\\\\\?\\\\'\n            unc_prefix = '\\\\\\\\?\\\\UNC\\\\'\n            new_unc_prefix = '\\\\\\\\'\n            cwd = os.getcwd()\n            # bpo-38081: Special case for realpath('nul')\n            if normcase(path) == normcase(devnull):\n                return '\\\\\\\\.\\\\NUL'\n        had_prefix = path.startswith(prefix)\n        if not had_prefix and not isabs(path):\n            path = join(cwd, path)\n        try:\n            path = _getfinalpathname(path)\n            initial_winerror = 0\n        except OSError as ex:\n            initial_winerror = ex.winerror\n            path = _getfinalpathname_nonstrict(path)\n        # The path returned by _getfinalpathname will always start with \\\\?\\ -\n        # strip off that prefix unless it was already provided on the original\n        # path.\n        if not had_prefix and path.startswith(prefix):\n            # For UNC paths, the prefix will actually be \\\\?\\UNC\\\n            # Handle that case as well.\n            if path.startswith(unc_prefix):\n                spath = new_unc_prefix + path[len(unc_prefix):]\n            else:\n                spath = path[len(prefix):]\n            # Ensure that the non-prefixed path resolves to the same path\n            try:\n                if _getfinalpathname(spath) == path:\n                    path = spath\n            except OSError as ex:\n                # If the path does not exist and originally did not exist, then\n                # strip the prefix anyway.\n                if ex.winerror == initial_winerror:\n                    path = spath\n        return path\n\n\n# Win9x family and earlier have no Unicode filename support.\nsupports_unicode_filenames = (hasattr(sys, \"getwindowsversion\") and\n                              sys.getwindowsversion()[3] >= 2)\n\ndef relpath(path, start=None):\n    \"\"\"Return a relative version of a path\"\"\"\n    path = os.fspath(path)\n    if isinstance(path, bytes):\n        sep = b'\\\\'\n        curdir = b'.'\n        pardir = b'..'\n    else:\n        sep = '\\\\'\n        curdir = '.'\n        pardir = '..'\n\n    if start is None:\n        start = curdir\n\n    if not path:\n        raise ValueError(\"no path specified\")\n\n    start = os.fspath(start)\n    try:\n        start_abs = abspath(normpath(start))\n        path_abs = abspath(normpath(path))\n        start_drive, start_rest = splitdrive(start_abs)\n        path_drive, path_rest = splitdrive(path_abs)\n        if normcase(start_drive) != normcase(path_drive):\n            raise ValueError(\"path is on mount %r, start on mount %r\" % (\n                path_drive, start_drive))\n\n        start_list = [x for x in start_rest.split(sep) if x]\n        path_list = [x for x in path_rest.split(sep) if x]\n        # Work out how much of the filepath is shared by start and path.\n        i = 0\n        for e1, e2 in zip(start_list, path_list):\n            if normcase(e1) != normcase(e2):\n                break\n            i += 1\n\n        rel_list = [pardir] * (len(start_list)-i) + path_list[i:]\n        if not rel_list:\n            return curdir\n        return join(*rel_list)\n    except (TypeError, ValueError, AttributeError, BytesWarning, DeprecationWarning):\n        genericpath._check_arg_types('relpath', path, start)\n        raise\n\n\n# Return the longest common sub-path of the sequence of paths given as input.\n# The function is case-insensitive and 'separator-insensitive', i.e. if the\n# only difference between two paths is the use of '\\' versus '/' as separator,\n# they are deemed to be equal.\n#\n# However, the returned path will have the standard '\\' separator (even if the\n# given paths had the alternative '/' separator) and will have the case of the\n# first path given in the sequence. Additionally, any trailing separator is\n# stripped from the returned path.\n\ndef commonpath(paths):\n    \"\"\"Given a sequence of path names, returns the longest common sub-path.\"\"\"\n\n    if not paths:\n        raise ValueError('commonpath() arg is an empty sequence')\n\n    paths = tuple(map(os.fspath, paths))\n    if isinstance(paths[0], bytes):\n        sep = b'\\\\'\n        altsep = b'/'\n        curdir = b'.'\n    else:\n        sep = '\\\\'\n        altsep = '/'\n        curdir = '.'\n\n    try:\n        drivesplits = [splitdrive(p.replace(altsep, sep).lower()) for p in paths]\n        split_paths = [p.split(sep) for d, p in drivesplits]\n\n        try:\n            isabs, = set(p[:1] == sep for d, p in drivesplits)\n        except ValueError:\n            raise ValueError(\"Can't mix absolute and relative paths\") from None\n\n        # Check that all drive letters or UNC paths match. The check is made only\n        # now otherwise type errors for mixing strings and bytes would not be\n        # caught.\n        if len(set(d for d, p in drivesplits)) != 1:\n            raise ValueError(\"Paths don't have the same drive\")\n\n        drive, path = splitdrive(paths[0].replace(altsep, sep))\n        common = path.split(sep)\n        common = [c for c in common if c and c != curdir]\n\n        split_paths = [[c for c in s if c and c != curdir] for s in split_paths]\n        s1 = min(split_paths)\n        s2 = max(split_paths)\n        for i, c in enumerate(s1):\n            if c != s2[i]:\n                common = common[:i]\n                break\n        else:\n            common = common[:len(s1)]\n\n        prefix = drive + sep if isabs else drive\n        return prefix + sep.join(common)\n    except (TypeError, AttributeError):\n        genericpath._check_arg_types('commonpath', *paths)\n        raise\n\n\ntry:\n    # The genericpath.isdir implementation uses os.stat and checks the mode\n    # attribute to tell whether or not the path is a directory.\n    # This is overkill on Windows - just pass the path to GetFileAttributes\n    # and check the attribute from there.\n    from nt import _isdir as isdir\nexcept ImportError:\n    # Use genericpath.isdir as imported above.\n    pass\n",794]},"functions":{"currentframe (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\inspect.py:1520)":["C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\inspect.py",1520],"<genexpr> (D:\\githubs\\DR\\libs\\utils\\py_logger.py:360)":["D:\\githubs\\DR\\libs\\utils\\py_logger.py",360],"get_key_from_dict (D:\\githubs\\DR\\libs\\utils\\py_logger.py:445)":["D:\\githubs\\DR\\libs\\utils\\py_logger.py",445],"_compile (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\re.py:289)":["C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\re.py",289],"sub (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\re.py:203)":["C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\re.py",203],"len_without_color_maker (D:\\githubs\\DR\\libs\\utils\\py_logger.py:465)":["D:\\githubs\\DR\\libs\\utils\\py_logger.py",465],"_get_bothseps (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:34)":["C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py",34],"splitdrive (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:124)":["C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py",124],"split (C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py:180)":["C:\\Users\\shenjack.SHENJACK-5600X\\AppData\\Local\\Programs\\Python\\Python38\\lib\\ntpath.py",180],"format_text (D:\\githubs\\DR\\libs\\utils\\py_logger.py:371)":["D:\\githubs\\DR\\libs\\utils\\py_logger.py",371],"make_log (D:\\githubs\\DR\\libs\\utils\\py_logger.py:348)":["D:\\githubs\\DR\\libs\\utils\\py_logger.py",348],"trace (D:\\githubs\\DR\\libs\\utils\\py_logger.py:390)":["D:\\githubs\\DR\\libs\\utils\\py_logger.py",390],"fine (D:\\githubs\\DR\\libs\\utils\\py_logger.py:397)":["D:\\githubs\\DR\\libs\\utils\\py_logger.py",397],"debug (D:\\githubs\\DR\\libs\\utils\\py_logger.py:404)":["D:\\githubs\\DR\\libs\\utils\\py_logger.py",404],"info (D:\\githubs\\DR\\libs\\utils\\py_logger.py:412)":["D:\\githubs\\DR\\libs\\utils\\py_logger.py",412],"warning (D:\\githubs\\DR\\libs\\utils\\py_logger.py:420)":["D:\\githubs\\DR\\libs\\utils\\py_logger.py",420],"error (D:\\githubs\\DR\\libs\\utils\\py_logger.py:428)":["D:\\githubs\\DR\\libs\\utils\\py_logger.py",428],"fatal (D:\\githubs\\DR\\libs\\utils\\py_logger.py:436)":["D:\\githubs\\DR\\libs\\utils\\py_logger.py",436],"test_logger (D:\\githubs\\DR\\libs\\utils\\py_logger.py:571)":["D:\\githubs\\DR\\libs\\utils\\py_logger.py",571]}}}